<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ranger | Gertjan Verhoeven</title>
    <link>/tags/ranger/</link>
      <atom:link href="/tags/ranger/index.xml" rel="self" type="application/rss+xml" />
    <description>ranger</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2019-2022</copyright><lastBuildDate>Mon, 20 Jun 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>ranger</title>
      <link>/tags/ranger/</link>
    </image>
    
    <item>
      <title>Optimal performance with Random Forests: does feature selection beat tuning?</title>
      <link>/post/random-forest-rfe_vs_tuning/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      <guid>/post/random-forest-rfe_vs_tuning/</guid>
      <description>


&lt;p&gt;&lt;em&gt;(Photo by &lt;a href=&#34;https://unsplash.com/@skamenar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&#34;&gt;Steven Kamenar&lt;/a&gt; on &lt;a href=&#34;https://unsplash.com/s/photos/forest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&#34;&gt;Unsplash&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The Random Forest algorithm is often said to perform well “out-of-the-box”, with no tuning or feature selection needed, even with so-called high-dimensional data, where we have a high number of features (predictors) relative to the number of observations.&lt;/p&gt;
&lt;p&gt;Here, we show that Random Forest can still be harmed by irrelevant features, and offer two ways of dealing with it. We can do so either by removing the irrelevant features (using a procedure called &lt;strong&gt;recursive feature elimination (RFE)&lt;/strong&gt;), or by &lt;strong&gt;tuning the algorithm&lt;/strong&gt;, increasing the number of features available during each split (the &lt;code&gt;mtry&lt;/code&gt; parameter in R) during training (model building).&lt;/p&gt;
&lt;p&gt;Furthermore, using a simulation study where I gradually increase the amount of &lt;strong&gt;noise&lt;/strong&gt; (irrelevant features) relative to the &lt;strong&gt;signal&lt;/strong&gt; (relevant features), we find that at some point the RF tuning approach no longer is able to achieve optimal performance. Under such (possibly extreme) circumstances, RF feature selection keeps performing well, filtering out the signal variables from the noise variables.&lt;/p&gt;
&lt;p&gt;But first, why should we care about this 2001 algorithm in 2022? Shouldn’t we be all be using deep learning by now (or doing bayesian statistics)?&lt;/p&gt;
&lt;div id=&#34;why-random-forest-is-my-favorite-ml-algorithm&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Why Random Forest is my favorite ML algorithm&lt;/h2&gt;
&lt;p&gt;The Random Forest algorithm &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-breiman01&#34; role=&#34;doc-biblioref&#34;&gt;Breiman 2001&lt;/a&gt;)&lt;/span&gt; is my favorite ML algorithm for cross-sectional, tabular data. Thanks to &lt;a href=&#34;https://mnwright.github.io/&#34;&gt;Marvin Wright&lt;/a&gt; a fast and reliable implementation exists for R called &lt;code&gt;ranger&lt;/code&gt;&lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-wright_ziegler17&#34; role=&#34;doc-biblioref&#34;&gt;Wright and Ziegler 2017&lt;/a&gt;)&lt;/span&gt;. For tabular data, RF seems to offer the highest value per unit of compute compared to other popular ML methods, such as Deep learning or Gradient Boosting algorithms such as &lt;strong&gt;XGBoost&lt;/strong&gt;. In this setting, predictive performance is often on par with Deep Learning or Gradient boosting &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-svetnik_etal05&#34; role=&#34;doc-biblioref&#34;&gt;Svetnik et al. 2005&lt;/a&gt;; &lt;a href=&#34;#ref-xu_etal21&#34; role=&#34;doc-biblioref&#34;&gt;Xu et al. 2021&lt;/a&gt;)&lt;/span&gt;. For classification prediction models, it has been shown to outperform logistic regression &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-couronne_etal18&#34; role=&#34;doc-biblioref&#34;&gt;Couronné, Probst, and Boulesteix 2018&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The Random Forest algorithm can provide a quick benchmark for the predictive performance of a set of predictors, that is hard to beat with models that explicitly formulate a interpretable model of a dependent variable, for example a linear regression model with interactions and non-linear transformations of the predictors. For a great talk on the Random Forest method, check out &lt;a href=&#34;https://www.youtube.com/watch?v=iVmsJJYjgNs&#34;&gt;Prof. Marvin Wright’s UseR talk from 2019 on YouTube&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;but-it-is-not-perfect-the-effect-of-irrelevant-variables&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;But it is not perfect: the effect of irrelevant variables&lt;/h2&gt;
&lt;p&gt;In that talk, Marvin Wright discusses the common claim that “Random Forest works well on high-dimensional data”. High-dimensional data is common in genetics, when we have say complete genomes for only a handful of subjects. The suggestion is that RF can be used on small datasets with lots of (irrelevant / noise) features without having to do variable selection first.&lt;/p&gt;
&lt;p&gt;To check this claim, Wright shows that RF performance is unaffected by adding 100 noise variables to the &lt;code&gt;iris&lt;/code&gt; dataset, a simple example classification problem with three different species. Because RF uses decision trees, it performs “automatic” feature (predictor / variable) selection as part of the model building process. This property of the algorithm is used to explain this result. A tree model will simply ignore the noise predictors and choose the relevant predictors instead.&lt;/p&gt;
&lt;p&gt;See the accompanying R notebook &lt;a href=&#34;https://github.com/gsverhoeven/hugo_source/blob/master/content/post/rf_rfe_post/prep_and_fit.Rmd&#34;&gt;prep_and_fit.Rmd&lt;/a&gt; that contains all the simulations I performed for this blog post. It also includes the simulation on the &lt;code&gt;iris&lt;/code&gt; dataset:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit_list &amp;lt;- readRDS(&amp;quot;rf_rfe_post/fitlist.rds&amp;quot;)
fit_list$algo &amp;lt;- paste0(fit_list$method, &amp;quot;_mtry_&amp;quot;, fit_list$mtry)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit_list %&amp;gt;% filter(ds_group == &amp;quot;df_iris&amp;quot; &amp;amp; algo == &amp;quot;ranger_mtry_default&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 17
##   model_id method mtry    ds_id ds_name      ds_group target  forest_type n_obs
##      &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;        &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;       &amp;lt;int&amp;gt;
## 1        1 ranger default     4 df_iris      df_iris  Species class         150
## 2        1 ranger default     5 df_iris_N100 df_iris  Species class         150
## # … with 8 more variables: n_features &amp;lt;dbl&amp;gt;, fit_id &amp;lt;int&amp;gt;, performance &amp;lt;dbl&amp;gt;,
## #   algo &amp;lt;chr&amp;gt;, performance_lower &amp;lt;dbl&amp;gt;, performance_upper &amp;lt;dbl&amp;gt;,
## #   performance_boot &amp;lt;dbl&amp;gt;, performance_boot_corr &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;source(&amp;quot;rf_rfe_post/plot_performance.R&amp;quot;)

plot_performance(data = fit_list %&amp;gt;% filter(ds_group == &amp;quot;df_iris&amp;quot; &amp;amp; algo == &amp;quot;ranger_mtry_default&amp;quot;),
                 axis_label = &amp;quot;Accuracy (% correct)&amp;quot;,
                 plot_title = &amp;quot;Adding 100 noise variables to the iris dataset&amp;quot;, 
                 facet_var = &amp;quot;algo&amp;quot;, x_var = &amp;quot;ds_name&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Indeed, the performance (here i looked at &lt;em&gt;Accuracy&lt;/em&gt; as percentage of observations correctly classified) is hardly affected.&lt;/p&gt;
&lt;p&gt;(As we will be doing a lot of model performance comparison, I added 90% bootstrapped confidence intervals for the performance metrics used in this post. This interval was generated from 1000 bootstrapped values of R2 using resampling on the vectors of (out-of-bag) predictions and the observed y-values (This deserves its own future blog post, if you can’t wait just check the &lt;a href=&#34;https://github.com/gsverhoeven/hugo_source/blob/master/content/post/rf_rfe_post/prep_and_fit.Rmd&#34;&gt;&lt;code&gt;prep_and_fit.Rmd&lt;/code&gt; notebook&lt;/a&gt; on my Github)).&lt;/p&gt;
&lt;p&gt;However, a counter example, where adding irrelevant features &lt;strong&gt;does hurt&lt;/strong&gt; performance, is quickly found. In &lt;a href=&#34;https://topepo.github.io/caret/recursive-feature-elimination.html&#34;&gt;Chapter 20&lt;/a&gt; of the documentation of &lt;code&gt;caret&lt;/code&gt;, a popular ML package in &lt;code&gt;R&lt;/code&gt;, Max Kuhn introduces the regression problem &lt;strong&gt;Friedman 1&lt;/strong&gt; to illustrate the problem, as well as a possible solution. See for a different example in the literature &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-genuer_etal10&#34; role=&#34;doc-biblioref&#34;&gt;Genuer, Poggi, and Tuleau-Malot 2010&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mlbench.friedman1()&lt;/code&gt; simulates the regression problem &lt;strong&gt;Friedman 1&lt;/strong&gt;. Inputs are 10 independent variables uniformly distributed on the interval [0,1], only 5 out of these 10 are actually used in the formula to generate the dependent variable &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(y = 10 sin(\pi x_1 x_2) + 20 (x_3 - 0.5)^2 + 10 x_4 + 5 x_5 + \epsilon\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt; is distributed &lt;span class=&#34;math inline&#34;&gt;\(Normal(0, 1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;(source: &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-friedman91&#34; role=&#34;doc-biblioref&#34;&gt;Friedman 1991&lt;/a&gt;; &lt;a href=&#34;#ref-breiman96&#34; role=&#34;doc-biblioref&#34;&gt;Breiman 1996&lt;/a&gt;)&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;Kuhn added 40 more noise variables to the dataset and simulated N = 100 observations. Now only five predictors contain signal, whereas the other 45 contain noise. Random Forest with its default setting of &lt;code&gt;mtry&lt;/code&gt; shows poor performance, and only after performing feature selection (removing the irrelevant variables) optimal performance is achieved (see below for more about feature selection, here the point is the reduced performance after adding noise).&lt;/p&gt;
&lt;p&gt;I also reproduced this analysis, but with N = 1000 and with 0, 100 and 500 &lt;strong&gt;additional&lt;/strong&gt; noise variables added (instead of 40).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_performance(data = fit_list %&amp;gt;% filter(ds_group == &amp;quot;df_friedman1&amp;quot; &amp;amp; algo %in% c(&amp;quot;ranger_mtry_default&amp;quot;)),
                 axis_label = &amp;quot;R-squared (%)&amp;quot;,
                 plot_title = &amp;quot;Adding increasing amount of noise to the Friedman 1 dataset&amp;quot;, facet_var = &amp;quot;algo&amp;quot;, x_var = &amp;quot;ds_name&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can check the optimal performance by only including the relevant predictors &lt;span class=&#34;math inline&#34;&gt;\(x_1, x_2,x_3,x_4, x_5\)&lt;/span&gt; in the RF algorithm: such a model has an R-squared of around 88% (not shown). RF including both signal and five noise predictors, the original &lt;strong&gt;Friedman 1&lt;/strong&gt; problem, shows a slight drop in performance to 84% with the default &lt;code&gt;mtry&lt;/code&gt; value. After including an additional 100 noise variables, performance drops further to 56%. And if we add 500 instead of 100 additional noise variables, performance drops even further to 34% R2.&lt;/p&gt;
&lt;p&gt;So how to solve this? In this blog post, I will compare both RF &lt;strong&gt;hyperparameter tuning&lt;/strong&gt; and &lt;strong&gt;feature selection&lt;/strong&gt; in the presence of many irrelevant features.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;tuning-rf-or-removing-the-irrelevant-features&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Tuning RF or removing the irrelevant features?&lt;/h2&gt;
&lt;p&gt;It seems that most practical guidance to improve RF performance is on &lt;em&gt;tuning the algorithm hyperparameters&lt;/em&gt;, arguing that Random Forest as a tree-based method has built-in feature selection, alleviating the need to remove irrelevant features.&lt;/p&gt;
&lt;p&gt;This is demonstrated by the many guides on (RF/ML) algorithm tuning found online. For example, a currently popular book “Hands-On Machine Learning” &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-geron19&#34; role=&#34;doc-biblioref&#34;&gt;Géron 2019&lt;/a&gt;)&lt;/span&gt; contains a short paragraph on the importance of selecting / creating relevant features, but then goes on to discuss hyperparameter tuning at great length for the remainder of the book.&lt;/p&gt;
&lt;p&gt;Some evidence that RF tuning is sufficient to deal with irrelevant features is provided by Kuhn &amp;amp; Johnson &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-kuhn_johnson19&#34; role=&#34;doc-biblioref&#34;&gt;Kuhn and Johnson 2019&lt;/a&gt;)&lt;/span&gt;.
In their book available online, they have a section called &lt;a href=&#34;http://www.feat.engineering/feature-selection-simulation.html&#34;&gt;Effect of Irrelevant Features&lt;/a&gt;. For simulated data with 20 informative predictors, they find that after RF tuning (which is not mentioned in the book but is clear from the &lt;a href=&#34;https://github.com/topepo/FES_Selection_Simulation&#34;&gt;R code provided on Github&lt;/a&gt;), the algorithm is (mostly) robust to up to 200 extra noise variables.&lt;/p&gt;
&lt;p&gt;So let’s start with RF tuning.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-effect-of-rf-tuning-demonstrated-on-openml-datasets&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The effect of RF tuning demonstrated on OpenML datasets&lt;/h2&gt;
&lt;p&gt;To experiment with RF tuning and compare it with RF feature selection, I needed datasets. Using simulated data is always an option, but with such data it is not always clear what the practical significance of our findings is.&lt;/p&gt;
&lt;p&gt;So I needed (regression) datasets that are not too big, nor too small, and where RF tuning has a substantial effect. Finding these was not easy: Surprisingly, online tutorials for RF hyperparameter tuning often only show small improvements in performance.&lt;/p&gt;
&lt;p&gt;Here the benchmarking study of Philipp Probst on RF tuning came to the rescue, as he identified three datasets where RF tuning has a significant effect. Probst created a suite of 29 regression datasets (&lt;code&gt;OpenML-Reg-19&lt;/code&gt;), where he compared tuned ranger with default ranger. The selection of the datasets is described &lt;a href=&#34;https://github.com/PhilippPro/OpenML-bench&#34;&gt;here&lt;/a&gt;. The datasets he used are all made available by &lt;a href=&#34;https://new.openml.org/&#34;&gt;OpenML.org&lt;/a&gt;. This is a website dedicated to reproducible, open ML, with a large collection of datasets, focused on benchmarking and performance comparison.&lt;/p&gt;
&lt;p&gt;Furthermore, For the RF tuning, he created an R package, aptly called &lt;code&gt;tuneRanger&lt;/code&gt;, available on CRAN as well as on &lt;a href=&#34;https://github.com/PhilippPro/tuneRanger&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ignoring the red and green lines, and comparing the tuned vs default ranger, it is clear that on many datasets, tuning hardly improves things. Here we see the reputation of RF, that it works well straight out of the box, borne out in practice.&lt;/p&gt;
&lt;p&gt;However, a few did, and three stood out (blue line above dashed line).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/probst_tuning_ranger.png&#34; style=&#34;width:66.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure created by Philipp Probst and reproduced from his TuneRanger Github repository&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As he made all his code available on Github, I could identify the three datasets as being &lt;a href=&#34;https://www.openml.org/search?type=data&amp;amp;sort=runs&amp;amp;id=560&amp;amp;status=active&#34;&gt;bodyfat&lt;/a&gt;, &lt;a href=&#34;https://www.openml.org/search?type=data&amp;amp;sort=runs&amp;amp;id=505&amp;amp;status=active&#34;&gt;tecator&lt;/a&gt; and &lt;a href=&#34;https://www.openml.org/search?type=data&amp;amp;sort=runs&amp;amp;id=308&amp;amp;status=active&#34;&gt;puma32H&lt;/a&gt;.
&lt;code&gt;Puma32H&lt;/code&gt; is noteworthy in that it is a classic ML dataset for a simulated PUMA 560 robotarm, that contains mostly irrelevant features (30 out of 32) &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-geurts_etal06&#34; role=&#34;doc-biblioref&#34;&gt;Geurts, Ernst, and Wehenkel 2006&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/puma560_schematic.png&#34; style=&#34;width:50.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For these three datasets, I reproduced the results of default &lt;code&gt;ranger()&lt;/code&gt; and tuned the &lt;code&gt;mtry&lt;/code&gt; parameter.&lt;/p&gt;
&lt;p&gt;mtry? what try?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;rf-tuning-the-mtry-parameter&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;RF tuning: the mtry parameter&lt;/h2&gt;
&lt;p&gt;A great resource for tuning RF is a 2019 review paper by Probst &lt;em&gt;et al.&lt;/em&gt; called ‘Hyperparameters and Tuning Strategies for Random Forest’ &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-probst_etal19&#34; role=&#34;doc-biblioref&#34;&gt;Probst, Wright, and Boulesteix 2019&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;They conclude:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Out of these parameters, mtry is most influential both according to the literature and in our own experiments. The best value of mtry depends on the number of variables that are related to the outcome.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In this blog post, we use &lt;code&gt;mtry&lt;/code&gt; as the only tuning parameter of Random Forest. This is the number of randomly drawn features that is available to split on as the tree is grown. It can vary between 1 and the total number of features in the dataset. From the literature and my own experience, this is the hyperparameter that matters most. For an interesting discussion on the effect of &lt;code&gt;mtry&lt;/code&gt; on the complexity of the final model (the tree ensemble) see &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-goldstein_etal11&#34; role=&#34;doc-biblioref&#34;&gt;Goldstein, Polley, and Briggs 2011&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Reproducing the results using &lt;code&gt;ranger()&lt;/code&gt; myself, and playing around with the &lt;code&gt;mtry&lt;/code&gt; parameter, I discovered that the three datasets have something in common: they all contain only a few variables that are predictive of the outcome, in the presence of a lot of irrelevant variables. Furthermore, setting &lt;code&gt;mtry&lt;/code&gt; at its maximum value was sufficient to achieve the performance found by Probst after using &lt;code&gt;tuneRanger&lt;/code&gt; (blue line in the figure above).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_performance(data =fit_list %&amp;gt;% filter(ds_group == &amp;quot;openML&amp;quot; &amp;amp; algo %in% c(&amp;quot;ranger_mtry_default&amp;quot;, &amp;quot;ranger_mtry_max&amp;quot;)),
                 axis_label = &amp;quot;R-squared (%)&amp;quot;,
                 plot_title = &amp;quot;mtry tuning for optimal performance on OpenML datasets&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;That tuning &lt;code&gt;mtry&lt;/code&gt; for a Random Forest is important in the presence of many irrelevant features was already shown by Hastie &lt;em&gt;et al.&lt;/em&gt; in their 2009 classic book “Elements of statistical Learning” (p615, Figure 15.7) &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-hastie_etal09&#34; role=&#34;doc-biblioref&#34;&gt;Hastie et al. 2009&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;They showed that if &lt;code&gt;mtry&lt;/code&gt; is kept at its default (square root of &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;, the total number of features), as more irrelevant variables are added, the probability of the &lt;strong&gt;relevant&lt;/strong&gt; features being selected for splitting becomes too low, decreasing performance. So for datasets with a large proportion of irrelevant features, &lt;code&gt;mtry&lt;/code&gt; tuning (increasing its value) is crucially important.&lt;/p&gt;
&lt;p&gt;Before we move on to RF feature selection, let’s see what else we can tune in RF apart from &lt;code&gt;mtry&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;rf-tuning-what-else-can-we-tune&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;RF tuning: what else can we tune?&lt;/h2&gt;
&lt;p&gt;With respect to the other RF parameters, a quick rundown:&lt;/p&gt;
&lt;p&gt;I left the &lt;code&gt;num.trees&lt;/code&gt; at its default (500), and chose “variance” as the &lt;code&gt;splitrule&lt;/code&gt; for regression problems, and “gini” for classification problems (alternative is “extratrees” which implements the “Extremely Randomized Trees” method &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-geurts_etal06&#34; role=&#34;doc-biblioref&#34;&gt;Geurts, Ernst, and Wehenkel 2006&lt;/a&gt;)&lt;/span&gt; but I have yet to see convincing results that demonstrate ERT performs substantially better). I checked a few key results at lower and higher &lt;code&gt;num.trees&lt;/code&gt; as well (100 and 1000 respectively): 100 is a bit low for the Out-of-bag predictions to stabilize, 500 appears to be a sweet spot, with no improvement in R-squared mean or a significant reduction in R2 variance between runs either.&lt;/p&gt;
&lt;p&gt;I played around a bit with the &lt;code&gt;min.node.size&lt;/code&gt; parameter, for which often the sequence 5,10,20 is mentioned to vary over. Setting this larger should reduce computation, since it leads to shorter trees, but for the datasets here, the effect is on the order of say 10% reduction, which does not warrant tuning it IMO. I left this at its default of 5 for regression and 1 for classification.&lt;/p&gt;
&lt;p&gt;Finally, Marvin Wright points to results from Probst &lt;em&gt;et al.&lt;/em&gt;&lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-probst_etal19&#34; role=&#34;doc-biblioref&#34;&gt;Probst, Wright, and Boulesteix 2019&lt;/a&gt;)&lt;/span&gt; that show &lt;code&gt;sample.fraction&lt;/code&gt; to be an important parameter as well. This determines the number of samples from the dataset to draw for each tree. I have not looked into this, instead I used the default setting from &lt;code&gt;ranger()&lt;/code&gt; which is to sample with replacement, and to use all samples for each tree, i.e &lt;code&gt;sample.fraction = 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To conclude: we focus on &lt;code&gt;mtry&lt;/code&gt; and leave the rest alone.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;from-rf-tuning-to-rf-feature-selection&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;From RF tuning to RF feature selection&lt;/h2&gt;
&lt;p&gt;A natural question to ask is why not simply get rid of the irrelevant features? Why not perform feature selection?&lt;/p&gt;
&lt;p&gt;The classic book &lt;em&gt;Applied Predictive Modeling&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-kuhn_johnson13&#34; role=&#34;doc-biblioref&#34;&gt;Kuhn and Johnson 2013&lt;/a&gt;)&lt;/span&gt; contains a similar simulation experiment (on the &lt;code&gt;solubility&lt;/code&gt; dataset, for RF I reproduce their results below) showing the negative effects of including many irrelevant features in a Random Forest model (chapter 18). And indeed, instead of tuning RF, they suggest &lt;strong&gt;removing the irrelevant features altogether&lt;/strong&gt;, i.e. to perform feature selection. Also their follow up book on Feature engineering and selection by Kuhn &amp;amp; Johnson from 2019 &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-kuhn_johnson19&#34; role=&#34;doc-biblioref&#34;&gt;Kuhn and Johnson 2019&lt;/a&gt;)&lt;/span&gt; &lt;a href=&#34;http://www.feat.engineering/recursive-feature-elimination.html&#34;&gt;elaborates on this&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;rf-feature-selection&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;RF Feature selection&lt;/h2&gt;
&lt;p&gt;To perform feature selection, we use the recursive feature elimination (RFE) procedure, implemented for &lt;code&gt;ranger&lt;/code&gt; in &lt;code&gt;caret&lt;/code&gt; as the function &lt;code&gt;rfe()&lt;/code&gt;. This is a backward feature selection method, starting will all predictors and in stepwise manner dropping the least important features &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-guyon_etal02&#34; role=&#34;doc-biblioref&#34;&gt;Guyon et al. 2002&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;When the full model is created, a measure of variable importance is computed that ranks the predictors from most important to least. […] At each stage of the search, the least important predictors are iteratively eliminated prior to rebuilding the model.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;— Pages 494-495, Applied Predictive Modeling, 2013.&lt;/p&gt;
&lt;p&gt;(Computationally, I think it makes more sense to start with only the most relevant features and add more features in a stepwise fashion until performance no longer improves but reaches a plateau. But that would require writing my own “forward procedure”, which I save for another day.)&lt;/p&gt;
&lt;p&gt;As this is a procedure that drops predictors that do not correlate with the outcome, we have to be extremely careful that we end up with something that generalizes to unseen data. In &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-kuhn_johnson13&#34; role=&#34;doc-biblioref&#34;&gt;Kuhn and Johnson 2013&lt;/a&gt;)&lt;/span&gt; they convincingly show that a special procedure is necessary, with two loops of cross validation first described by &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-ambroise_mclachlan02&#34; role=&#34;doc-biblioref&#34;&gt;Ambroise and McLachlan 2002&lt;/a&gt;)&lt;/span&gt;. The outer loop sets aside one fold that is not used for feature selection (and optionally model tuning), whereas the inner loop selects features and tunes the model. See &lt;a href=&#34;http://www.feat.engineering/selection-overfitting.html#selection-overfitting&#34;&gt;Chapter 10.4&lt;/a&gt; of their follow up book &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-kuhn_johnson19&#34; role=&#34;doc-biblioref&#34;&gt;Kuhn and Johnson 2019&lt;/a&gt;)&lt;/span&gt; for detailed documentation and examples.&lt;/p&gt;
&lt;p&gt;Typically, as we start removing irrelevant features, performs either stays constant or even increases until we reach the point where performs drops. At this point features that are predictive of the outcome are getting removed.&lt;/p&gt;
&lt;p&gt;Note that we do not tune the &lt;code&gt;mtry&lt;/code&gt; variable of RF in this procedure. Empirically, it has been observed that this either has no effect, or only leads to marginal improvements &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-kuhn_johnson19&#34; role=&#34;doc-biblioref&#34;&gt;Kuhn and Johnson 2019&lt;/a&gt;; &lt;a href=&#34;#ref-svetnik_etal04&#34; role=&#34;doc-biblioref&#34;&gt;Svetnik, Liaw, and Tong 2004&lt;/a&gt;)&lt;/span&gt;. Conceptually, tuning (increasing) &lt;code&gt;mtry&lt;/code&gt; is a way to reduce the effect of irrelevant features. Since we are applying a procedure to &lt;strong&gt;remove&lt;/strong&gt; the irrelevant features instead, it makes sense that tuning has little benefit here.&lt;/p&gt;
&lt;p&gt;(As I was curious, I nevertheless created a set of custom helper functions for &lt;code&gt;rfe()&lt;/code&gt; that tune &lt;code&gt;mtry&lt;/code&gt; during the feature selection procedure, see the &lt;code&gt;RangerTuneFuncs.R&lt;/code&gt; script, results not shown)&lt;/p&gt;
&lt;!-- While mtry is a tuning parameter for random forest models, the default value of mtry≈sqrt(p) tends to provide good overall performance. While tuning this parameter may have led to better performance, our experience is that the improvement tends to be marginal --&gt;
&lt;p&gt;So we expect that either tuning &lt;code&gt;mtry&lt;/code&gt; , OR performing feature selection solves the problem of irrelevant variables.
Indeed, this is also what we find on the three OpenML datasets. Both the RF tuning approach (Setting &lt;code&gt;mtry&lt;/code&gt; at its maximum value) as well as the RF feature selection using RFE result in optimal performance:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_performance(data =fit_list %&amp;gt;% filter(ds_group == &amp;quot;openML&amp;quot;),
                 axis_label = &amp;quot;R-squared (%)&amp;quot;,
                 plot_title = &amp;quot;mtry tuning vs feature selection for three OpenML datasets&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Can RF feature selection (“ranger-rfe” in the plot below) solve our problems with the “Friedman 1” simulated data as well?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_performance(data = fit_list %&amp;gt;% filter(ds_group == &amp;quot;df_friedman1&amp;quot;),
                 axis_label = &amp;quot;R-squared (%)&amp;quot;,
                 plot_title = &amp;quot;Feature selection vs tuning on simulated data with noise added&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Yes, it can! And here we see that RF tuning is not enough, we really need to identify and remove the irrelevant variables.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;N.b.&lt;/strong&gt; For &lt;code&gt;df_friedman1_N100&lt;/code&gt;, the RFE tuning grid is based on equidistant steps starting with &lt;span class=&#34;math inline&#34;&gt;\(p = 2\)&lt;/span&gt; and included as smallest values only &lt;span class=&#34;math inline&#34;&gt;\(p = 2\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(p = 14\)&lt;/span&gt;, so it skipped the optimal value &lt;span class=&#34;math inline&#34;&gt;\(p = 5\)&lt;/span&gt;. This explains the sub optimal performance for RFE with 105 noise variables added. For &lt;code&gt;df_friedman1_N500&lt;/code&gt;, the tuning grid was exponential and included 2, 3, 6 and 12 (up to &lt;span class=&#34;math inline&#34;&gt;\(p = 510\)&lt;/span&gt;). The RFE procedure selected &lt;span class=&#34;math inline&#34;&gt;\(p = 6\)&lt;/span&gt; as optimal, this included as top five variables the five predictors that contained the signal.&lt;/p&gt;
&lt;p&gt;A similar pattern is seen for the &lt;code&gt;solubility&lt;/code&gt; dataset with noise added, an example taken from &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-kuhn_johnson13&#34; role=&#34;doc-biblioref&#34;&gt;Kuhn and Johnson 2013&lt;/a&gt;)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_performance(data = fit_list %&amp;gt;% filter(ds_group == &amp;quot;solubility&amp;quot; &amp;amp; ds_name != &amp;quot;solubility_N500_perm&amp;quot;),
                 axis_label = &amp;quot;R-squared (%)&amp;quot;,
                 plot_title = &amp;quot;Feature selection vs tuning on Solubility data with noise added&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Note that on the original &lt;code&gt;solubility&lt;/code&gt; dataset, neither tuning nor feature selection is needed, RF already performs well out of the box.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;doing-it-wrong-rf-tuning-after-rfe-feature-selection-on-the-same-dataset&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Doing it wrong: RF tuning after RFE feature selection on the same dataset&lt;/h2&gt;
&lt;p&gt;Finally, we echo others in stressing the importance of using a special nested cross-validation loop to perform the feature selection and performance assessment, especially when a test set is not available. “If the model is refit using only the important predictors, model performance almost certainly improves” according to Kuhn &amp;amp; Johnson (APM 2013). I also found a blog post [here] that references &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-hastie_etal09&#34; role=&#34;doc-biblioref&#34;&gt;Hastie et al. 2009&lt;/a&gt;)&lt;/span&gt; regarding the dangers when using both feature selection and cross validation.&lt;/p&gt;
&lt;p&gt;To drive the point home, I have taken the &lt;code&gt;solubility&lt;/code&gt; dataset with 500 noise predictors added (951 observation, with in total 228 + 500 = 728 predictors), and scrambled the &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; variable we wish to predict. With scrambling I mean shuffling the values of &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;, thereby removing any correlation with the predictors. This is an easy way to check our procedure for any data leakage from the training set to the test set where we evaluate performance.&lt;/p&gt;
&lt;p&gt;All three RF modeling approaches now correctly report an R-squared of approximately 0%.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_performance(fit_list %&amp;gt;% filter(ds_name == &amp;quot;solubility_N500_perm&amp;quot;),
                 axis_label = &amp;quot;R-squared (%)&amp;quot;,
                 plot_title = &amp;quot;Feature selection vs tuning on simulated data after scrambling y&amp;quot;) + expand_limits(y = 90)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-03-random_forest_rfe_vs_tuning_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;However, if we do RF tuning on this scrambled dataset, &lt;strong&gt;after&lt;/strong&gt; we performed RFE feature selection, we get cross-validated R-squared values of 5-10%, purely based on noise variables “dredged” from the hundreds of variables we supplied to the algorithm. For full code see the &lt;a href=&#34;https://github.com/gsverhoeven/hugo_source/blob/master/content/post/rf_rfe_post/prep_and_fit.Rmd&#34;&gt;R notebook on my Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Note that I had to play around a bit with the RFE settings to not have it pick either the model with &lt;strong&gt;all&lt;/strong&gt; features or the model with only 1 feature: using &lt;code&gt;RMSE&lt;/code&gt; as a metric, and setting &lt;code&gt;pickSizeTolerance&lt;/code&gt; the procedure selected a model with 75 predictors.
Retraining this model using &lt;code&gt;caret::train&lt;/code&gt; gave me the result below)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;trainObject &amp;lt;- readRDS(&amp;quot;rf_rfe_post/post_rfe_train.rds&amp;quot;)

trainObject&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Random Forest 
## 
## 951 samples
##  75 predictor
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 857, 855, 855, 856, 856, 858, ... 
## Resampling results across tuning parameters:
## 
##   mtry  RMSE      Rsquared    MAE     
##    1    2.001946  0.07577078  1.562253
##    2    1.997836  0.06977449  1.558831
##    3    1.993046  0.07166917  1.559323
##    5    1.983549  0.08801892  1.548190
##    9    1.988541  0.06977760  1.551304
##   15    1.987132  0.06717113  1.551576
##   25    1.989876  0.06165605  1.552562
##   44    1.985765  0.06707004  1.550177
##   75    1.984745  0.06737729  1.548531
## 
## Tuning parameter &amp;#39;splitrule&amp;#39; was held constant at a value of variance
## 
## Tuning parameter &amp;#39;min.node.size&amp;#39; was held constant at a value of 5
## RMSE was used to select the optimal model using the smallest value.
## The final values used for the model were mtry = 5, splitrule = variance
##  and min.node.size = 5.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This illustrates the dangers of performing massive variable selection exercises without the proper safeguards.
Aydin Demircioğlu wrote a paper that identifies several radiomics studies that performed cross-validation as a separate step after feature selection, and thus got it wrong &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-demircioglu21&#34; role=&#34;doc-biblioref&#34;&gt;Demircioğlu 2021&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;To conclude: we have shown that for in the presence of (many) irrelevant variables, RF performance suffers and something needs to be done.
This can be either tuning the RF, most importantly increasing the &lt;code&gt;mtry&lt;/code&gt; parameter, or identifying and removing the irrelevant features using the RFE procedure &lt;code&gt;rfe()&lt;/code&gt; part of the &lt;code&gt;caret&lt;/code&gt; package in R. Selecting only relevant features has the added advantage of providing insight into which features contain the signal.&lt;/p&gt;
&lt;p&gt;Interestingly, on the “real” datasets (openML, the solubility QSAR data) both tuning and feature selection give the same result. Only when we use simulated data (Friedman1), or if we add noise to real datasets (iris, solubility)) we find that &lt;code&gt;mtry&lt;/code&gt; tuning is not enough, and removal of the irrelevant features is needed to obtain optimal performance.&lt;/p&gt;
&lt;p&gt;The fact that tuning and feature selection are rarely compared head to head might be that both procedures have different implicit use cases: ML tuning is often performed on datasets that are thought to contain mostly relevant predictors. In this setting feature selection does not improve performance, as it primarily works through the removal of noise variables. On the other hand, feature selection is often performed on high-dimensional datasets where prior information is available telling us that relatively few predictors are related to the outcome, and the many noise variables in the data can negatively influence RF performance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;N.b.&lt;/strong&gt; As is often the case with simulation studies, an open question is how far we can generalize our results. &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-svetnik_etal03&#34; role=&#34;doc-biblioref&#34;&gt;Svetnik et al. 2003&lt;/a&gt;)&lt;/span&gt; identified a classification dataset &lt;strong&gt;Cox-2&lt;/strong&gt; that exhibits unexpected behavior: The dataset gives optimal performance with &lt;code&gt;mtry&lt;/code&gt; at its maximum setting, indicative of a many irrelevant predictors, so we expect feature selection to find a smaller model that gives the same performance at default &lt;code&gt;mtry&lt;/code&gt;. However, surprisingly, performance only degraded after performing feature selection using RFE. I wrote the authors (Vladimir Svetnik and Andy Liaw) to ask for the dataset, unfortunately they suffered a data loss some time ago. They obtained the data from Greg Kauffman and Peter Jurs &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-kauffman_jurs01&#34; role=&#34;doc-biblioref&#34;&gt;Kauffman and Jurs 2001&lt;/a&gt;)&lt;/span&gt;, I reached out to them as well but did not receive a reply.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Acknowledgements&lt;/strong&gt;: I’d like to thank Philipp Probst and Anne-Laure Boulesteix for their constructive comments and suggestions on this blog post.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references csl-bib-body hanging-indent&#34;&gt;
&lt;div id=&#34;ref-ambroise_mclachlan02&#34; class=&#34;csl-entry&#34;&gt;
Ambroise, Christophe, and Geoffrey J. McLachlan. 2002. &lt;span&gt;“Selection Bias in Gene Extraction on the Basis of Microarray Gene-Expression Data.”&lt;/span&gt; &lt;em&gt;Proceedings of the National Academy of Sciences&lt;/em&gt; 99 (10): 6562–66.
&lt;/div&gt;
&lt;div id=&#34;ref-breiman96&#34; class=&#34;csl-entry&#34;&gt;
Breiman, Leo. 1996. &lt;span&gt;“Bagging Predictors.”&lt;/span&gt; &lt;em&gt;Machine Learning&lt;/em&gt; 24 (2): 123–40.
&lt;/div&gt;
&lt;div id=&#34;ref-breiman01&#34; class=&#34;csl-entry&#34;&gt;
———. 2001. &lt;span&gt;“Random Forests.”&lt;/span&gt; &lt;em&gt;Machine Learning&lt;/em&gt; 45 (1): 5–32.
&lt;/div&gt;
&lt;div id=&#34;ref-couronne_etal18&#34; class=&#34;csl-entry&#34;&gt;
Couronné, Raphael, Philipp Probst, and Anne-Laure Boulesteix. 2018. &lt;span&gt;“Random Forest Versus Logistic Regression: A Large-Scale Benchmark Experiment.”&lt;/span&gt; &lt;em&gt;BMC Bioinformatics&lt;/em&gt; 19 (1): 1–14.
&lt;/div&gt;
&lt;div id=&#34;ref-demircioglu21&#34; class=&#34;csl-entry&#34;&gt;
Demircioğlu, Aydin. 2021. &lt;span&gt;“Measuring the Bias of Incorrect Application of Feature Selection When Using Cross-Validation in Radiomics.”&lt;/span&gt; &lt;em&gt;Insights into Imaging&lt;/em&gt; 12 (1): 1–10.
&lt;/div&gt;
&lt;div id=&#34;ref-friedman91&#34; class=&#34;csl-entry&#34;&gt;
Friedman, Jerome H. 1991. &lt;span&gt;“Multivariate Adaptive Regression Splines.”&lt;/span&gt; &lt;em&gt;The Annals of Statistics&lt;/em&gt; 19 (1): 1–67.
&lt;/div&gt;
&lt;div id=&#34;ref-genuer_etal10&#34; class=&#34;csl-entry&#34;&gt;
Genuer, Robin, Jean-Michel Poggi, and Christine Tuleau-Malot. 2010. &lt;span&gt;“Variable Selection Using Random Forests.”&lt;/span&gt; &lt;em&gt;Pattern Recognition Letters&lt;/em&gt; 31 (14): 2225–36.
&lt;/div&gt;
&lt;div id=&#34;ref-geron19&#34; class=&#34;csl-entry&#34;&gt;
Géron, Aurélien. 2019. &lt;em&gt;Hands-on Machine Learning with Scikit-Learn, Keras, and TensorFlow: Concepts, Tools, and Techniques to Build Intelligent Systems&lt;/em&gt;. O’Reilly Media, Inc.
&lt;/div&gt;
&lt;div id=&#34;ref-geurts_etal06&#34; class=&#34;csl-entry&#34;&gt;
Geurts, Pierre, Damien Ernst, and Louis Wehenkel. 2006. &lt;span&gt;“Extremely Randomized Trees.”&lt;/span&gt; &lt;em&gt;Machine Learning&lt;/em&gt; 63 (1): 3–42.
&lt;/div&gt;
&lt;div id=&#34;ref-goldstein_etal11&#34; class=&#34;csl-entry&#34;&gt;
Goldstein, Benjamin A., Eric C. Polley, and Farren B. S. Briggs. 2011. &lt;span&gt;“Random forests for genetic association studies.”&lt;/span&gt; &lt;em&gt;Statistical Applications in Genetics and Molecular Biology&lt;/em&gt; 10 (1): 32. &lt;a href=&#34;https://doi.org/10.2202/1544-6115.1691&#34;&gt;https://doi.org/10.2202/1544-6115.1691&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-guyon_etal02&#34; class=&#34;csl-entry&#34;&gt;
Guyon, Isabelle, Jason Weston, Stephen Barnhill, and Vladimir Vapnik. 2002. &lt;span&gt;“Gene Selection for Cancer Classification Using Support Vector Machines.”&lt;/span&gt; &lt;em&gt;Machine Learning&lt;/em&gt; 46 (1): 389–422.
&lt;/div&gt;
&lt;div id=&#34;ref-hastie_etal09&#34; class=&#34;csl-entry&#34;&gt;
Hastie, Trevor, Robert Tibshirani, Jerome H. Friedman, and Jerome H. Friedman. 2009. &lt;em&gt;The Elements of Statistical Learning: Data Mining, Inference, and Prediction&lt;/em&gt;. Vol. 2. Springer.
&lt;/div&gt;
&lt;div id=&#34;ref-kauffman_jurs01&#34; class=&#34;csl-entry&#34;&gt;
Kauffman, Gregory W., and Peter C. Jurs. 2001. &lt;span&gt;“QSAR and k-Nearest Neighbor Classification Analysis of Selective Cyclooxygenase-2 Inhibitors Using Topologically-Based Numerical Descriptors.”&lt;/span&gt; &lt;em&gt;Journal of Chemical Information and Computer Sciences&lt;/em&gt; 41 (6): 1553–60. &lt;a href=&#34;https://doi.org/10.1021/ci010073h&#34;&gt;https://doi.org/10.1021/ci010073h&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-kuhn_johnson13&#34; class=&#34;csl-entry&#34;&gt;
Kuhn, Max, and Kjell Johnson. 2013. &lt;em&gt;Applied Predictive Modeling&lt;/em&gt;. Vol. 26. Springer.
&lt;/div&gt;
&lt;div id=&#34;ref-kuhn_johnson19&#34; class=&#34;csl-entry&#34;&gt;
———. 2019. &lt;em&gt;Feature Engineering and Selection: A Practical Approach for Predictive Models&lt;/em&gt;. CRC Press.
&lt;/div&gt;
&lt;div id=&#34;ref-probst_etal19&#34; class=&#34;csl-entry&#34;&gt;
Probst, Philipp, Marvin N. Wright, and Anne-Laure Boulesteix. 2019. &lt;span&gt;“Hyperparameters and Tuning Strategies for Random Forest.”&lt;/span&gt; &lt;em&gt;Wiley Interdisciplinary Reviews: Data Mining and Knowledge Discovery&lt;/em&gt; 9 (3): e1301.
&lt;/div&gt;
&lt;div id=&#34;ref-svetnik_etal04&#34; class=&#34;csl-entry&#34;&gt;
Svetnik, Vladimir, Andy Liaw, and Christopher Tong. 2004. &lt;span&gt;“Variable Selection in Random Forest with Application to Quantitative Structure-Activity Relationship.”&lt;/span&gt; &lt;em&gt;Proceedings of the 7th Course on Ensemble Methods for Learning Machines&lt;/em&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-svetnik_etal03&#34; class=&#34;csl-entry&#34;&gt;
Svetnik, Vladimir, Andy Liaw, Christopher Tong, J. Christopher Culberson, Robert P. Sheridan, and Bradley P. Feuston. 2003. &lt;span&gt;“Random Forest: A Classification and Regression Tool for Compound Classification and QSAR Modeling.”&lt;/span&gt; &lt;em&gt;Journal of Chemical Information and Computer Sciences&lt;/em&gt; 43 (6): 1947–58.
&lt;/div&gt;
&lt;div id=&#34;ref-svetnik_etal05&#34; class=&#34;csl-entry&#34;&gt;
Svetnik, Vladimir, Ting Wang, Christopher Tong, Andy Liaw, Robert P. Sheridan, and Qinghua Song. 2005. &lt;span&gt;“Boosting: An Ensemble Learning Tool for Compound Classification and QSAR Modeling.”&lt;/span&gt; &lt;em&gt;Journal of Chemical Information and Modeling&lt;/em&gt; 45 (3): 786–99.
&lt;/div&gt;
&lt;div id=&#34;ref-wright_ziegler17&#34; class=&#34;csl-entry&#34;&gt;
Wright, Marvin N., and Andreas Ziegler. 2017. &lt;span&gt;“Ranger: A Fast Implementation of Random Forests for High Dimensional Data in C++ and R.”&lt;/span&gt; &lt;em&gt;Journal of Statistical Software&lt;/em&gt; 77 (March): 1–17. &lt;a href=&#34;https://doi.org/10.18637/jss.v077.i01&#34;&gt;https://doi.org/10.18637/jss.v077.i01&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-xu_etal21&#34; class=&#34;csl-entry&#34;&gt;
Xu, Haoyin, Kaleab A. Kinfu, Will LeVine, Sambit Panda, Jayanta Dey, Michael Ainsworth, Yu-Chung Peng, Madi Kusmanov, Florian Engert, and Christopher M. White. 2021. &lt;span&gt;“When Are Deep Networks Really Better Than Decision Forests at Small Sample Sizes, and How?”&lt;/span&gt; &lt;em&gt;arXiv Preprint arXiv:2108.13637&lt;/em&gt;.
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Improving a parametric regression model using machine learning</title>
      <link>/post/interaction_detection/interaction-detection/</link>
      <pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate>
      <guid>/post/interaction_detection/interaction-detection/</guid>
      <description>
&lt;link href=&#34;/rmarkdown-libs/anchor-sections/anchor-sections.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/anchor-sections/anchor-sections.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;The idea is that comparing the predictions of an RF model with the predictions of an OLS model can inform us in what ways the OLS model fails to capture all non-linearities and interactions between the predictors. Subsequently, using partial dependence plots of the RF model can guide the modelling of the non-linearities in the OLS model. After this step, the discrepancies between the RF predictions and the OLS predictions should be caused by non-modeled interactions. Using an RF to predict the discrepancy itself can then be used to discover which predictors are involved in these interactions. We test this method on the classic &lt;code&gt;Boston Housing&lt;/code&gt; dataset to predict median house values (&lt;code&gt;medv&lt;/code&gt;). We indeed recover interactions that, as it turns, have already been found and documented in the literature.&lt;/p&gt;
&lt;div id=&#34;load-packages&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Load packages&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rm(list=ls())
#library(randomForest)
#library(party)
library(ranger)
library(data.table)
library(ggplot2)
library(MASS)

rdunif &amp;lt;- function(n,k) sample(1:k, n, replace = T)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;step-1-run-a-rf-on-the-boston-housing-set&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Step 1: Run a RF on the Boston Housing set&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_ranger &amp;lt;- ranger(medv ~ ., data = Boston,
                                  importance = &amp;quot;permutation&amp;quot;, num.trees = 500,
                                  mtry = 5, replace = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Extract the permutation importance measure.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;myres_tmp &amp;lt;- ranger::importance(my_ranger);
myres &amp;lt;- cbind(names(myres_tmp), myres_tmp,  i = 1)
#my_rownames &amp;lt;- row.names(myres)
myres &amp;lt;- data.table(myres)
setnames(myres, &amp;quot;V1&amp;quot;, &amp;quot;varname&amp;quot;)
setnames(myres, &amp;quot;myres_tmp&amp;quot;, &amp;quot;MeanDecreaseAccuracy&amp;quot;)
myres &amp;lt;- myres[, varname := as.factor(varname)]
myres &amp;lt;- myres[, MeanDecreaseAccuracy := as.numeric(MeanDecreaseAccuracy)]
myres &amp;lt;- myres[, i := as.integer(i)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(myres, 
       aes(x = reorder(factor(varname), MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) + 
  geom_point() + coord_flip()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fit-an-ols-to-the-boston-housing&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Fit an OLS to the Boston Housing&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_glm &amp;lt;- glm(medv ~., data = Boston, 
              family = &amp;quot;gaussian&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;compare-predictions-of-both-models&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Compare predictions of both models&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_RF &amp;lt;- predict(my_ranger, data = Boston)
#pred_RF$predictions
pred_GLM &amp;lt;- predict(my_glm, data = Boston)

plot(pred_RF$predictions, pred_GLM)
abline(0, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt; # Run a RF on the discrepancy&lt;/p&gt;
&lt;p&gt;Discrepancy is defined as the difference between the predictions of both models for each observation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_diff &amp;lt;- pred_RF$predictions - pred_GLM

my_ranger_diff &amp;lt;- ranger(Ydiff ~ . - medv, data = data.table(Ydiff = pred_diff, Boston),
                                  importance = &amp;quot;permutation&amp;quot;, num.trees = 500,
                                  mtry = 5, replace = TRUE)
my_ranger_diff&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Ranger result
## 
## Call:
##  ranger(Ydiff ~ . - medv, data = data.table(Ydiff = pred_diff,      Boston), importance = &amp;quot;permutation&amp;quot;, num.trees = 500, mtry = 5,      replace = TRUE) 
## 
## Type:                             Regression 
## Number of trees:                  500 
## Sample size:                      506 
## Number of independent variables:  13 
## Mtry:                             5 
## Target node size:                 5 
## Variable importance mode:         permutation 
## Splitrule:                        variance 
## OOB prediction error (MSE):       5.151991 
## R squared (OOB):                  0.6674631&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It turns out the RF can &amp;quot;explain&amp;quot; 67% of these discrepancies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;myres_tmp &amp;lt;- ranger::importance(my_ranger_diff)
myres &amp;lt;- cbind(names(myres_tmp), myres_tmp,  i = 1)
#my_rownames &amp;lt;- row.names(myres)
myres &amp;lt;- data.table(myres)
setnames(myres, &amp;quot;V1&amp;quot;, &amp;quot;varname&amp;quot;)
setnames(myres, &amp;quot;myres_tmp&amp;quot;, &amp;quot;MeanDecreaseAccuracy&amp;quot;)
myres &amp;lt;- myres[, varname := as.factor(varname)]
myres &amp;lt;- myres[, MeanDecreaseAccuracy := as.numeric(MeanDecreaseAccuracy)]
myres &amp;lt;- myres[, i := as.integer(i)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(myres, 
       aes(x = reorder(factor(varname), MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) + 
  geom_point() + coord_flip()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It turns out that &lt;code&gt;rm&lt;/code&gt; and &lt;code&gt;lstat&lt;/code&gt; are the variables that best predict the discrepancy.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_glm_int &amp;lt;- glm(medv ~. + rm:lstat, data = Boston, 
              family = &amp;quot;gaussian&amp;quot;)
summary(my_glm_int)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## glm(formula = medv ~ . + rm:lstat, family = &amp;quot;gaussian&amp;quot;, data = Boston)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -21.5738   -2.3319   -0.3584    1.8149   27.9558  
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)   6.073638   5.038175   1.206 0.228582    
## crim         -0.157100   0.028808  -5.453 7.85e-08 ***
## zn            0.027199   0.012020   2.263 0.024083 *  
## indus         0.052272   0.053475   0.978 0.328798    
## chas          2.051584   0.750060   2.735 0.006459 ** 
## nox         -15.051627   3.324807  -4.527 7.51e-06 ***
## rm            7.958907   0.488520  16.292  &amp;lt; 2e-16 ***
## age           0.013466   0.011518   1.169 0.242918    
## dis          -1.120269   0.175498  -6.383 4.02e-10 ***
## rad           0.320355   0.057641   5.558 4.49e-08 ***
## tax          -0.011968   0.003267  -3.664 0.000276 ***
## ptratio      -0.721302   0.115093  -6.267 8.06e-10 ***
## black         0.003985   0.002371   1.681 0.093385 .  
## lstat         1.844883   0.191833   9.617  &amp;lt; 2e-16 ***
## rm:lstat     -0.418259   0.032955 -12.692  &amp;lt; 2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## (Dispersion parameter for gaussian family taken to be 16.98987)
## 
##     Null deviance: 42716  on 505  degrees of freedom
## Residual deviance:  8342  on 491  degrees of freedom
## AIC: 2886
## 
## Number of Fisher Scoring iterations: 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interaction we have added is indeed highly significant.&lt;/p&gt;
&lt;p&gt;Compare approximate out-of-sample prediction accuracy using AIC:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;AIC(my_glm)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3027.609&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;AIC(my_glm_int)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2886.043&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Indeed, the addition of the interaction greatly increases the prediction accuracy.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;repeat-this-process&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Repeat this process&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_RF &amp;lt;- predict(my_ranger, data = Boston)
#pred_RF$predictions
pred_GLM &amp;lt;- predict(my_glm_int, data = Boston)

plot(pred_RF$predictions, pred_GLM)
abline(0, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_diff &amp;lt;- pred_RF$predictions - pred_GLM

my_ranger_diff2 &amp;lt;- ranger(Ydiff ~ . - medv, data = data.table(Ydiff = pred_diff, Boston),
                                  importance = &amp;quot;permutation&amp;quot;, num.trees = 500,
                                  mtry = 5, replace = TRUE)
my_ranger_diff2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Ranger result
## 
## Call:
##  ranger(Ydiff ~ . - medv, data = data.table(Ydiff = pred_diff,      Boston), importance = &amp;quot;permutation&amp;quot;, num.trees = 500, mtry = 5,      replace = TRUE) 
## 
## Type:                             Regression 
## Number of trees:                  500 
## Sample size:                      506 
## Number of independent variables:  13 
## Mtry:                             5 
## Target node size:                 5 
## Variable importance mode:         permutation 
## Splitrule:                        variance 
## OOB prediction error (MSE):       5.604118 
## R squared (OOB):                  0.4399596&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;myres_tmp &amp;lt;- ranger::importance(my_ranger_diff2)
myres &amp;lt;- cbind(names(myres_tmp), myres_tmp,  i = 1)
#my_rownames &amp;lt;- row.names(myres)
myres &amp;lt;- data.table(myres)
setnames(myres, &amp;quot;V1&amp;quot;, &amp;quot;varname&amp;quot;)
setnames(myres, &amp;quot;myres_tmp&amp;quot;, &amp;quot;MeanDecreaseAccuracy&amp;quot;)
myres &amp;lt;- myres[, varname := as.factor(varname)]
myres &amp;lt;- myres[, MeanDecreaseAccuracy := as.numeric(MeanDecreaseAccuracy)]
myres &amp;lt;- myres[, i := as.integer(i)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(myres, 
       aes(x = reorder(factor(varname), MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) + 
  geom_point() + coord_flip()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now the variables that best predict the discrepancy are &lt;code&gt;lstat&lt;/code&gt; and &lt;code&gt;dis&lt;/code&gt;. Add these two variables as an interaction.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_glm_int2 &amp;lt;- glm(medv ~. + rm:lstat + lstat:dis, data = Boston, 
              family = &amp;quot;gaussian&amp;quot;)
summary(my_glm_int2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## glm(formula = medv ~ . + rm:lstat + lstat:dis, family = &amp;quot;gaussian&amp;quot;, 
##     data = Boston)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -23.3918   -2.2997   -0.4077    1.6475   27.6766  
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)   1.552991   5.107295   0.304 0.761201    
## crim         -0.139370   0.028788  -4.841 1.73e-06 ***
## zn            0.042984   0.012550   3.425 0.000667 ***
## indus         0.066690   0.052878   1.261 0.207834    
## chas          1.760779   0.743688   2.368 0.018290 *  
## nox         -11.544280   3.404577  -3.391 0.000753 ***
## rm            8.640503   0.513593  16.824  &amp;lt; 2e-16 ***
## age          -0.002127   0.012067  -0.176 0.860140    
## dis          -1.904982   0.268056  -7.107 4.22e-12 ***
## rad           0.304689   0.057000   5.345 1.39e-07 ***
## tax          -0.011220   0.003228  -3.476 0.000554 ***
## ptratio      -0.641380   0.115418  -5.557 4.51e-08 ***
## black         0.003756   0.002339   1.606 0.108924    
## lstat         1.925223   0.190368  10.113  &amp;lt; 2e-16 ***
## rm:lstat     -0.466947   0.034897 -13.381  &amp;lt; 2e-16 ***
## dis:lstat     0.076716   0.020009   3.834 0.000143 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## (Dispersion parameter for gaussian family taken to be 16.52869)
## 
##     Null deviance: 42716.3  on 505  degrees of freedom
## Residual deviance:  8099.1  on 490  degrees of freedom
## AIC: 2873.1
## 
## Number of Fisher Scoring iterations: 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;AIC(my_glm_int2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2873.087&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;AIC(my_glm_int)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2886.043&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We conclude that the second interaction also results in significant model improvement.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;a-more-ambitious-goal-try-and-improve-harrison-rubinfelds-model-formula-for-boston-housing&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;A more ambitious goal: Try and improve Harrison &amp;amp; Rubinfeld&#39;s model formula for Boston housing&lt;/h1&gt;
&lt;p&gt;So far, we assumed that all relationships are linear. Harrison and Rubinfeld have created a model without interactions, but with transformations to correct for skewness, heteroskedasticity etc. Let&#39;s see if we can improve upon this model equation by applying our method to search for interactions. Their formula predicts &lt;code&gt;log(medv)&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Harrison and Rubinfeld (1978) model
my_glm_hr &amp;lt;- glm(log(medv) ~ I(rm^2) + age + log(dis) + log(rad) + tax + ptratio + 
                     black + I(black^2) + log(lstat) + crim + zn + indus + chas + I(nox^2), data = Boston, 
              family = &amp;quot;gaussian&amp;quot;)

summary(my_glm_hr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## glm(formula = log(medv) ~ I(rm^2) + age + log(dis) + log(rad) + 
##     tax + ptratio + black + I(black^2) + log(lstat) + crim + 
##     zn + indus + chas + I(nox^2), family = &amp;quot;gaussian&amp;quot;, data = Boston)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -0.73091  -0.09274  -0.00710   0.09800   0.78607  
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  4.474e+00  1.579e-01  28.343  &amp;lt; 2e-16 ***
## I(rm^2)      6.634e-03  1.313e-03   5.053 6.15e-07 ***
## age          3.491e-05  5.245e-04   0.067 0.946950    
## log(dis)    -1.927e-01  3.325e-02  -5.796 1.22e-08 ***
## log(rad)     9.613e-02  1.905e-02   5.047 6.35e-07 ***
## tax         -4.295e-04  1.222e-04  -3.515 0.000481 ***
## ptratio     -2.977e-02  5.024e-03  -5.926 5.85e-09 ***
## black        1.520e-03  5.068e-04   3.000 0.002833 ** 
## I(black^2)  -2.597e-06  1.114e-06  -2.331 0.020153 *  
## log(lstat)  -3.695e-01  2.491e-02 -14.833  &amp;lt; 2e-16 ***
## crim        -1.157e-02  1.246e-03  -9.286  &amp;lt; 2e-16 ***
## zn           7.257e-05  5.034e-04   0.144 0.885430    
## indus       -1.943e-04  2.360e-03  -0.082 0.934424    
## chas         9.180e-02  3.305e-02   2.777 0.005690 ** 
## I(nox^2)    -6.566e-01  1.129e-01  -5.815 1.09e-08 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## (Dispersion parameter for gaussian family taken to be 0.03299176)
## 
##     Null deviance: 84.376  on 505  degrees of freedom
## Residual deviance: 16.199  on 491  degrees of freedom
## AIC: -273.48
## 
## Number of Fisher Scoring iterations: 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_ranger_log &amp;lt;- ranger(log(medv) ~ ., data = Boston,
                                  importance = &amp;quot;permutation&amp;quot;, num.trees = 500,
                                  mtry = 5, replace = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_RF &amp;lt;- predict(my_ranger_log, data = Boston)
#pred_RF$predictions
pred_GLM &amp;lt;- predict(my_glm_hr, data = Boston)

plot(pred_RF$predictions, pred_GLM)
abline(0, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For low predicted values both models differ in a systematic way. This suggests that there exists a remaining pattern that is picked up by RF but not by the OLS model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_diff &amp;lt;- pred_RF$predictions - pred_GLM

my_ranger_log_diff &amp;lt;- ranger(Ydiff ~ . - medv, data = data.table(Ydiff = pred_diff, Boston),
                                  importance = &amp;quot;permutation&amp;quot;, num.trees = 500,
                                  mtry = 5, replace = TRUE)
my_ranger_log_diff&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Ranger result
## 
## Call:
##  ranger(Ydiff ~ . - medv, data = data.table(Ydiff = pred_diff,      Boston), importance = &amp;quot;permutation&amp;quot;, num.trees = 500, mtry = 5,      replace = TRUE) 
## 
## Type:                             Regression 
## Number of trees:                  500 
## Sample size:                      506 
## Number of independent variables:  13 
## Mtry:                             5 
## Target node size:                 5 
## Variable importance mode:         permutation 
## Splitrule:                        variance 
## OOB prediction error (MSE):       0.009132647 
## R squared (OOB):                  0.5268126&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The RF indicates that 54% of the discrepancy can be &amp;quot;explained&amp;quot; by RF.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;myres_tmp &amp;lt;- ranger::importance(my_ranger_log_diff)
myres &amp;lt;- cbind(names(myres_tmp), myres_tmp,  i = 1)
#my_rownames &amp;lt;- row.names(myres)
myres &amp;lt;- data.table(myres)
setnames(myres, &amp;quot;V1&amp;quot;, &amp;quot;varname&amp;quot;)
setnames(myres, &amp;quot;myres_tmp&amp;quot;, &amp;quot;MeanDecreaseAccuracy&amp;quot;)
myres &amp;lt;- myres[, varname := as.factor(varname)]
myres &amp;lt;- myres[, MeanDecreaseAccuracy := as.numeric(MeanDecreaseAccuracy)]
myres &amp;lt;- myres[, i := as.integer(i)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(myres, 
       aes(x = reorder(factor(varname), MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) + 
  geom_point() + coord_flip()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Add the top 2 vars as an interaction to their model equation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_glm_hr_int &amp;lt;- glm(log(medv) ~ I(rm^2) + age + log(dis) + log(rad) + tax + ptratio + 
                     black + I(black^2) + log(lstat) + crim + zn + indus + chas + I(nox^2) +
                   lstat:nox, data = Boston, 
              family = &amp;quot;gaussian&amp;quot;)
summary(my_glm_hr_int)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## glm(formula = log(medv) ~ I(rm^2) + age + log(dis) + log(rad) + 
##     tax + ptratio + black + I(black^2) + log(lstat) + crim + 
##     zn + indus + chas + I(nox^2) + lstat:nox, family = &amp;quot;gaussian&amp;quot;, 
##     data = Boston)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -0.70340  -0.09274  -0.00665   0.10068   0.75004  
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  4.243e+00  1.613e-01  26.304  &amp;lt; 2e-16 ***
## I(rm^2)      7.053e-03  1.286e-03   5.484 6.66e-08 ***
## age         -3.146e-04  5.174e-04  -0.608  0.54354    
## log(dis)    -2.254e-01  3.317e-02  -6.795 3.15e-11 ***
## log(rad)     9.829e-02  1.862e-02   5.278 1.96e-07 ***
## tax         -4.589e-04  1.196e-04  -3.838  0.00014 ***
## ptratio     -2.990e-02  4.910e-03  -6.089 2.30e-09 ***
## black        1.445e-03  4.955e-04   2.917  0.00370 ** 
## I(black^2)  -2.470e-06  1.089e-06  -2.268  0.02376 *  
## log(lstat)  -2.143e-01  3.989e-02  -5.373 1.20e-07 ***
## crim        -1.046e-02  1.238e-03  -8.448 3.40e-16 ***
## zn           7.309e-04  5.099e-04   1.434  0.15234    
## indus       -8.166e-05  2.307e-03  -0.035  0.97178    
## chas         8.746e-02  3.231e-02   2.707  0.00704 ** 
## I(nox^2)    -3.618e-01  1.256e-01  -2.880  0.00415 ** 
## lstat:nox   -2.367e-02  4.819e-03  -4.911 1.24e-06 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## (Dispersion parameter for gaussian family taken to be 0.03150809)
## 
##     Null deviance: 84.376  on 505  degrees of freedom
## Residual deviance: 15.439  on 490  degrees of freedom
## AIC: -295.79
## 
## Number of Fisher Scoring iterations: 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;AIC(my_glm_hr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -273.4788&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;AIC(my_glm_hr_int)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -295.7931&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in a significant improvement!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;repeat-this-procedure&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Repeat this procedure&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_RF &amp;lt;- predict(my_ranger_log, data = Boston)
#pred_RF$predictions
pred_GLM &amp;lt;- predict(my_glm_hr_int, data = Boston)

plot(pred_RF$predictions, pred_GLM)
abline(0, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-23-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred_diff &amp;lt;- pred_RF$predictions - pred_GLM

my_ranger_log_diff2 &amp;lt;- ranger(Ydiff ~ . - medv, data = data.table(Ydiff = pred_diff, Boston),
                                  importance = &amp;quot;permutation&amp;quot;, num.trees = 500,
                                  mtry = 5, replace = TRUE)
my_ranger_log_diff2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Ranger result
## 
## Call:
##  ranger(Ydiff ~ . - medv, data = data.table(Ydiff = pred_diff,      Boston), importance = &amp;quot;permutation&amp;quot;, num.trees = 500, mtry = 5,      replace = TRUE) 
## 
## Type:                             Regression 
## Number of trees:                  500 
## Sample size:                      506 
## Number of independent variables:  13 
## Mtry:                             5 
## Target node size:                 5 
## Variable importance mode:         permutation 
## Splitrule:                        variance 
## OOB prediction error (MSE):       0.008653356 
## R squared (OOB):                  0.5201821&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;myres_tmp &amp;lt;- ranger::importance(my_ranger_log_diff2)
myres &amp;lt;- cbind(names(myres_tmp), myres_tmp,  i = 1)
#my_rownames &amp;lt;- row.names(myres)
myres &amp;lt;- data.table(myres)
setnames(myres, &amp;quot;V1&amp;quot;, &amp;quot;varname&amp;quot;)
setnames(myres, &amp;quot;myres_tmp&amp;quot;, &amp;quot;MeanDecreaseAccuracy&amp;quot;)
myres &amp;lt;- myres[, varname := as.factor(varname)]
myres &amp;lt;- myres[, MeanDecreaseAccuracy := as.numeric(MeanDecreaseAccuracy)]
myres &amp;lt;- myres[, i := as.integer(i)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(myres, 
       aes(x = reorder(factor(varname), MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) + 
  geom_point() + coord_flip()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/interaction_detection/interaction-detection_files/figure-html/unnamed-chunk-26-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we add lstat and dis as an interaction.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_glm_hr_int2 &amp;lt;- glm(log(medv) ~ I(rm^2) + age + log(dis) + log(rad) + tax + ptratio + 
                     black + I(black^2) + log(lstat) + crim + zn + indus + chas + I(nox^2) +
                   lstat:nox + lstat:dis, data = Boston, 
              family = &amp;quot;gaussian&amp;quot;)
summary(my_glm_hr_int2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## glm(formula = log(medv) ~ I(rm^2) + age + log(dis) + log(rad) + 
##     tax + ptratio + black + I(black^2) + log(lstat) + crim + 
##     zn + indus + chas + I(nox^2) + lstat:nox + lstat:dis, family = &amp;quot;gaussian&amp;quot;, 
##     data = Boston)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -0.70136  -0.08746  -0.00589   0.08857   0.76349  
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  4.535e+00  1.712e-01  26.481  &amp;lt; 2e-16 ***
## I(rm^2)      7.498e-03  1.266e-03   5.924 5.94e-09 ***
## age         -1.262e-03  5.504e-04  -2.293  0.02226 *  
## log(dis)    -4.065e-01  5.203e-02  -7.813 3.43e-14 ***
## log(rad)     9.668e-02  1.828e-02   5.290 1.85e-07 ***
## tax         -4.622e-04  1.173e-04  -3.940 9.35e-05 ***
## ptratio     -2.640e-02  4.881e-03  -5.409 9.93e-08 ***
## black        1.313e-03  4.871e-04   2.696  0.00727 ** 
## I(black^2)  -2.172e-06  1.071e-06  -2.029  0.04303 *  
## log(lstat)  -3.181e-01  4.553e-02  -6.987 9.23e-12 ***
## crim        -1.049e-02  1.215e-03  -8.635  &amp;lt; 2e-16 ***
## zn           9.078e-04  5.019e-04   1.809  0.07108 .  
## indus       -2.733e-04  2.264e-03  -0.121  0.90395    
## chas         7.166e-02  3.191e-02   2.246  0.02515 *  
## I(nox^2)    -2.569e-01  1.255e-01  -2.048  0.04113 *  
## lstat:nox   -2.729e-02  4.798e-03  -5.689 2.21e-08 ***
## lstat:dis    3.906e-03  8.754e-04   4.462 1.01e-05 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## (Dispersion parameter for gaussian family taken to be 0.03033711)
## 
##     Null deviance: 84.376  on 505  degrees of freedom
## Residual deviance: 14.835  on 489  degrees of freedom
## AIC: -313.99
## 
## Number of Fisher Scoring iterations: 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;AIC(my_glm_hr_int2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -313.9904&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;AIC(my_glm_hr_int)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -295.7931&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And again we find an improvement in model fit.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;have-these-interactions-already-been-reported-on-in-the-literature&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Have these interactions already been reported on in the literature?&lt;/h1&gt;
&lt;p&gt;Tom Minka reports on his website an analysis of interactions in the Boston Housing set:&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://alumni.media.mit.edu/~tpminka/courses/36-350.2001/lectures/day30/&#34; class=&#34;uri&#34;&gt;http://alumni.media.mit.edu/~tpminka/courses/36-350.2001/lectures/day30/&lt;/a&gt;) &lt;code&gt;&amp;gt; summary(fit3) Coefficients:                   Estimate Std. Error t value Pr(&amp;gt;|t|)     (Intercept)      -227.5485    49.2363  -4.622 4.87e-06 *** lstat              50.8553    20.3184   2.503 0.012639 *   rm                 38.1245     7.0987   5.371 1.21e-07 *** dis               -16.8163     2.9174  -5.764 1.45e-08 *** ptratio            14.9592     2.5847   5.788 1.27e-08 *** lstat:rm           -6.8143     3.1209  -2.183 0.029475 *   lstat:dis           4.8736     1.3940   3.496 0.000514 *** lstat:ptratio      -3.3209     1.0345  -3.210 0.001412 **  rm:dis              2.0295     0.4435   4.576 5.99e-06 *** rm:ptratio         -1.9911     0.3757  -5.299 1.76e-07 *** lstat:rm:dis       -0.5216     0.2242  -2.327 0.020364 *   lstat:rm:ptratio    0.3368     0.1588   2.121 0.034423 *&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Rob mcCulloch, using BART (bayesian additive regression trees) also examines interactions in the Boston Housing data. There the co-occurence within trees is used to discover interactions:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;The second, interaction detection, uncovers which pairs of variables interact in analogous fashion by keeping track of the percentage of trees in the sum in which both variables occur.  This exploits the fact that a sum-of-trees model captures an interaction between xi and xj by using them both for splitting rules in the same tree.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.rob-mcculloch.org/some_papers_and_talks/papers/working/cgm_as.pdf&#34; class=&#34;uri&#34;&gt;http://www.rob-mcculloch.org/some_papers_and_talks/papers/working/cgm_as.pdf&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;boston_uit_bart_book.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;We conclude that this appears a fruitfull approach to at least discovering where a regression model can be improved.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
