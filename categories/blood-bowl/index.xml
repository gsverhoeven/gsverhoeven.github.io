<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blood Bowl | Gertjan Verhoeven</title>
    <link>/categories/blood-bowl/</link>
      <atom:link href="/categories/blood-bowl/index.xml" rel="self" type="application/rss+xml" />
    <description>Blood Bowl</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2019-2022</copyright><lastBuildDate>Tue, 01 Nov 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Blood Bowl</title>
      <link>/categories/blood-bowl/</link>
    </image>
    
    <item>
      <title>Classifying Blood Bowl teams using clustered heatmaps</title>
      <link>/post/blood-bowl-cluster-heatmap/</link>
      <pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate>
      <guid>/post/blood-bowl-cluster-heatmap/</guid>
      <description>


&lt;p&gt;&lt;em&gt;(Photo by &lt;a href=&#34;https://twitter.com/erikcats&#34;&gt;Erik Cats&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;“If you graph the numbers of any system, patterns emerge” is one of my favorite movie quotes (from Darren Aronofsky’s cult movie about mathematics &lt;span class=&#34;math inline&#34;&gt;\(\pi\)&lt;/span&gt; (“pi”)). In this post we’ll graph the numbers from the Blood Bowl Fantasy football game, and see what patterns emerge. Blood Bowl is a board game that can be summarized as “fantasy-chess-with-dice”, but this would hardly do the game justice. For example, in chess both players play with the same pieces, but in Blood Bowl, almost 30 different teams (e.g. orcs, elves, etc) are available to choose from, each team with different skills that require different playing styles. In addition, Blood Bowl coaches must assemble and paint their playing pieces themselves, making it a creative hobby as well.&lt;/p&gt;
&lt;p&gt;For this blog post, we have a look at similarities and differences between the different Blood Bowl 2020 teams, and see where the newly introduced &lt;strong&gt;Black Orc&lt;/strong&gt; and &lt;strong&gt;Khorne&lt;/strong&gt; teams fit in. Using data analysis, we can cluster teams that have similar (average) match performance statistics and graph the data using &lt;strong&gt;heatmaps&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Heatmaps are a graphical representation of the data, with for example darker colors representing higher numbers. This allows patterns to emerge visually, and deviations on the patterns are also easy to spot. (Fun fact: a hundred years ago, people already “shaded matrices” but did not call it a heatmap yet &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-wilkinson_friendly09&#34; role=&#34;doc-biblioref&#34;&gt;Wilkinson and Friendly 2009&lt;/a&gt;)&lt;/span&gt;.)&lt;/p&gt;
&lt;p&gt;We use match performance data from &lt;a href=&#34;https://fumbbl.com&#34;&gt;FUMBBL.com&lt;/a&gt; where Blood Bowl 2020 can be played online. For a previous blog post that describes the process of scraping the data &lt;a href=&#34;https://gsverhoeven.github.io/post/blood-bowl-fumbbl-dataset/&#34;&gt;see here&lt;/a&gt;. I made the match data (currently from August 2020 up to June 2022) publicly available in a &lt;a href=&#34;https://github.com/gsverhoeven/fumbbl_datasets&#34;&gt;Github repository&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;team-play-style-categories&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Team play style categories&lt;/h1&gt;
&lt;p&gt;The most common way to classify the 25-30 different Blood Bowl teams is to distinguish four categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bash (e.g. Orcs)&lt;/li&gt;
&lt;li&gt;Agile (or Dash) (e.g. Wood Elf)&lt;/li&gt;
&lt;li&gt;Hybrid (e.g. Humans)&lt;/li&gt;
&lt;li&gt;Stunty (e.g. Halflings)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To formally classify a team we can use the follow decision tree, taking as input the most common roster choices for a team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does the team roster have a lot of Stunty players and a few Big Guys with negatrait?
&lt;ul&gt;
&lt;li&gt;yes classify as &lt;strong&gt;Stunty&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;no continue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Does the team roster have 4+ players with Strength skill access but &amp;lt; 4 players with Agility access?
&lt;ul&gt;
&lt;li&gt;yes classify as &lt;strong&gt;Bash&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;no continue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Does the team roster have 4+ players with Agility skill access but &amp;lt; 4 players with Strength access?
&lt;ul&gt;
&lt;li&gt;yes classify as &lt;strong&gt;Agile / Dash&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;no classify as &lt;strong&gt;Hybrid&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As an example, &lt;strong&gt;Shambling Undead&lt;/strong&gt; are typically played with 2 wights and 2 mummies (4 players with Strength access), but also with four Ghoul runners (4 players with Agility access), so this team is classified as &lt;strong&gt;Hybrid&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Main source for this scheme is &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-dode17&#34; role=&#34;doc-biblioref&#34;&gt;Dode 2017&lt;/a&gt;)&lt;/span&gt;, but the bash/dash/hybrid/stunty categorization is widespread, for example at &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-breidr15&#34; role=&#34;doc-biblioref&#34;&gt;Breidr 2015&lt;/a&gt;)&lt;/span&gt;, &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-amiral17&#34; role=&#34;doc-biblioref&#34;&gt;Amiral 2017&lt;/a&gt;)&lt;/span&gt; and &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-schlice18a&#34; role=&#34;doc-biblioref&#34;&gt;Schlice 2018&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;It will be interesting to compare the patterns in the data with this categorization.
In the next section we’ll discuss the various match statistics available from FUMBBL, but first we need to prep the data.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;read-and-prep-the-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Read and prep the data&lt;/h1&gt;
&lt;p&gt;We start with reading in the scraped FUMBBL match data, see my previous blog posts mentioned above for details.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Load packages
library(tidyverse)
library(ggfortify)
library(ggrepel)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df_mbt &amp;lt;- read.csv(file = &amp;quot;../../../fumbbl_datasets/datasets/current/df_mbt.csv&amp;quot;)

race_types &amp;lt;- unique(df_mbt %&amp;gt;% 
                       select(race_name, race_type) %&amp;gt;%
                       filter(race_type != &amp;quot;&amp;quot;) %&amp;gt;%
                       arrange(race_type))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This blog post focusses on the Blood Bowl 2020 ruleset, for this we need the “Competitive” division from FUMBBL.
(I performed the analysis for the older divisions using the 2016 ruleset as well, the plots can be found at the end of this blog post. )&lt;/p&gt;
&lt;p&gt;A blog post from Schlice &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-schlice18a&#34; role=&#34;doc-biblioref&#34;&gt;Schlice 2018&lt;/a&gt;)&lt;/span&gt; got me interested in BB team classification using data. In his post, he makes heavy use of functional programming using R’s &lt;code&gt;purrr&lt;/code&gt; package. This allows us to write a function and have this function work in parallel on a list of objects, and have it return the results also in list form.&lt;/p&gt;
&lt;p&gt;As this was new to me, I decided to adapt his code to process the four divisions simultaneously. To do so, I wrote a function &lt;code&gt;filter_division()&lt;/code&gt; that takes the source data and selects only matches from a particular division:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;divisions &amp;lt;- c(&amp;quot;Competitive&amp;quot;, &amp;quot;Blackbox&amp;quot;, &amp;quot;Ranked&amp;quot;, &amp;quot;Regular_league&amp;quot;)

filter_division &amp;lt;- function(div_name){
  df_mbt %&amp;gt;% 
  filter(division_name == div_name) %&amp;gt;%
  filter(race_name != &amp;quot;Treeman&amp;quot;) %&amp;gt;%
  filter(race_name != &amp;quot;Simyin&amp;quot;)
}

data_tables &amp;lt;- purrr::map(divisions, filter_division)
names(data_tables) &amp;lt;- divisions&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;data_tables&lt;/code&gt; now contains a list of four datasets, one for each division.&lt;/p&gt;
&lt;p&gt;Next step is to select the variables we are interested in.
Again we use the &lt;code&gt;purrr::map()&lt;/code&gt; function to apply our selection function at once to all four datasets:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select_stats &amp;lt;- function(df) {
  df %&amp;gt;% 
  select(race_name, race_type, team_score, away_team_score:away_cas_rip) %&amp;gt;%
  select(-(home_cas_bh:home_cas_rip), -(away_cas_bh:away_cas_rip))
}

data_tables &amp;lt;- map(data_tables, select_stats)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We end up with the following set of variables:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data_tables$Competitive %&amp;gt;% colnames()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;race_name&amp;quot;       &amp;quot;race_type&amp;quot;       &amp;quot;team_score&amp;quot;      &amp;quot;away_team_score&amp;quot;
##  [5] &amp;quot;home_comp&amp;quot;       &amp;quot;home_pass&amp;quot;       &amp;quot;home_rush&amp;quot;       &amp;quot;home_block&amp;quot;     
##  [9] &amp;quot;home_foul&amp;quot;       &amp;quot;home_cas&amp;quot;        &amp;quot;away_comp&amp;quot;       &amp;quot;away_pass&amp;quot;      
## [13] &amp;quot;away_rush&amp;quot;       &amp;quot;away_block&amp;quot;      &amp;quot;away_foul&amp;quot;       &amp;quot;away_cas&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;a-quick-summary-of-the-fummbl-match-statistics&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;A quick summary of the FUMMBL match statistics&lt;/h1&gt;
&lt;p&gt;The match statistics that are made available by FUMBBL are all related to important events during Blood Bowl gameplay.
Of course, teams with similar stats can still be different on some aspect not captured in the data, so we keep that in mind.&lt;/p&gt;
&lt;p&gt;The most obvious one is &lt;strong&gt;scoring Touchdowns&lt;/strong&gt; (&lt;code&gt;team_score&lt;/code&gt; and &lt;code&gt;away_team_score&lt;/code&gt;). As this involves getting the ball in the end zone of the opposing player, stats for actions that contribute to scoring such as &lt;strong&gt;passing the ball&lt;/strong&gt; are also present. There is the number of &lt;strong&gt;completed passes&lt;/strong&gt; (&lt;code&gt;home_comp&lt;/code&gt; and &lt;code&gt;away_comp&lt;/code&gt;) as well as the &lt;strong&gt;net passing distance&lt;/strong&gt; (with distance towards the opposing endzone counted positive and counted negative for passes in the opposite direction) (&lt;code&gt;home_pass&lt;/code&gt; and &lt;code&gt;away_pass&lt;/code&gt;). As passing is risky, running the ball into the endzone is the most common way to score. For running with the ball FUMBBL has the &lt;strong&gt;rushing&lt;/strong&gt; statistic. This name was chosen some 20 years ago, and now may lead to confusion as under the BB2020 rules moving extra squares is called “rushing” (previously called “Going-for-it” or GFI).&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;rushing&lt;/strong&gt; statistic is described in a &lt;a href=&#34;https://www.fumbbl.com/index.php?name=PNphpBB2&amp;amp;file=viewtopic&amp;amp;t=1344&amp;amp;postdays=0&amp;amp;postorder=asc&amp;amp;start=15&#34;&gt;2004 (!) FUMBBL forum post by SkiJunkie (the author of the predecessor of FUMBBL)&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;running/passing in the wrong direction counts negative. 
So if you run one step forward then one step back, your net rushing is 0.

Running/passing up and down neither adds nor subtracts. Getting pushed/thrown does not count. 
Only movement made during the players move who has the ball counts.

So, you can end up with negative rushing/passing. &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is great! The rushing statistic captures both &lt;strong&gt;ball possession&lt;/strong&gt; as well as &lt;strong&gt;the maximum movement of typical ball handlers in each team&lt;/strong&gt;. For example, in a Skaven team, the ball is typically handled by Gutter Runners, that have a maximum movement of 9. Compare this to the Dwarf team, where the Dwarf runner only has movement 6.&lt;/p&gt;
&lt;p&gt;Finally, we have the statistics related towards &lt;strong&gt;taking out opposing players&lt;/strong&gt;. This involves &lt;strong&gt;blocking&lt;/strong&gt;, leading to blocking &lt;strong&gt;casualties&lt;/strong&gt;, as well as &lt;strong&gt;fouling&lt;/strong&gt; (illegally hitting players that are already down). For blocking, the total number of blocks thrown is tracked (&lt;code&gt;home_block&lt;/code&gt; and &lt;code&gt;away_block&lt;/code&gt;), for casualties we have the number of players who suffer a casualty (&lt;code&gt;home_cas&lt;/code&gt; , &lt;code&gt;away_cas&lt;/code&gt;) and for fouling we have the number of fouls performed by each team (&lt;code&gt;home_foul&lt;/code&gt;, &lt;code&gt;away_foul&lt;/code&gt;). For casualties, we use both the number of casualties &lt;strong&gt;inflicted&lt;/strong&gt; as well as casualties &lt;strong&gt;suffered&lt;/strong&gt; (&lt;code&gt;home_cas&lt;/code&gt; and &lt;code&gt;away_cas&lt;/code&gt;). The average amount of casualties suffered quantifies the vulnerability of a team, and will likely be related to the average armour value (AV) of a team.&lt;/p&gt;
&lt;p&gt;As we are interested in statistics at the team level (not for individual matches), we take the average of all the statistics by team:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;divisions &amp;lt;- c(&amp;quot;Competitive&amp;quot;, &amp;quot;Blackbox&amp;quot;, &amp;quot;Ranked&amp;quot;, &amp;quot;Regular_league&amp;quot;)

df_agg &amp;lt;- data_tables$Competitive %&amp;gt;% 
  group_by(race_name, race_type) %&amp;gt;% 
  summarise(Blocks = mean(home_block), 
            Completions = mean(home_comp),
            Fouls = mean(home_foul),
            Distance_passed = mean(home_pass), 
            Running_w_ball = mean(home_rush), 
            Cas_inflicted = mean(home_cas),
            Cas_suffered = mean(away_cas), 
            Touchdowns = mean(team_score),
            size = n())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `summarise()` has grouped output by &amp;#39;race_name&amp;#39;. You can override using the
## `.groups` argument.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dim(df_agg)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 28 11&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This gives us 11 numbers for 28 different BB2020 teams.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;so-which-teams-have-similar-stats&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;So which teams have similar stats?&lt;/h1&gt;
&lt;p&gt;Next, we want to compare the different Blood Bowl teams on their match statistics with each other, and see which races have comparable stats.&lt;/p&gt;
&lt;p&gt;If we have only one statistic, it is easy: we can just plot the different teams on one axis, the value of the statistic on the other axis, sort them and see which races are closest by.&lt;/p&gt;
&lt;p&gt;Lets do that for the &lt;strong&gt;number of blocks made&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;options(dplyr.summarise.inform = FALSE)

ggplot(df_agg, aes(x = reorder(race_name, Blocks), y = Blocks, size = size, col = race_type)) +
         geom_point() + scale_size_area() + coord_flip() + labs(x = &amp;quot;team name&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-11-01_clustered_heatmaps_blood_bowl_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;
The different colors visualize the Team classification described above.
We can see that the average number of blocks is already pretty predictive of team type.&lt;/p&gt;
&lt;p&gt;But races can be similar if we look at &lt;strong&gt;blocks&lt;/strong&gt;, but dissimilar if we look at e.g. &lt;strong&gt;passing&lt;/strong&gt;. So lets make a few plots with each plot comparing two different metrics (code hidden for readability):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(patchwork)

(p1 | p2)/(p3 | p4) / (p5 | plot_spacer()) +   plot_layout(guides = &amp;#39;collect&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `geom_smooth()` using formula &amp;#39;y ~ x&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-11-01_clustered_heatmaps_blood_bowl_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Looking at the plots, we can see that there are clear patterns here. Some metrics are inherently related: Teams that make more passes during a match also cover more passing distance, that is only logical. But there are also patterns that are related to what makes teams different: teams that make more blocks tend to pass less (because they are less good at it).&lt;/p&gt;
&lt;p&gt;Given these patterns, we also see teams that do not conform to the pattern: For example, in the top left plot, the &lt;strong&gt;Goblin&lt;/strong&gt; and &lt;strong&gt;Snotling&lt;/strong&gt; teams tend to make less blocks, but also less passes compared to other teams. And for the top middle plot we see that &lt;strong&gt;Halflings&lt;/strong&gt; are an exception: Given how much they pass, we would expect a higher passing distance. (A quick look at their roster explains this: Halflings have dedicated Catchers (making passing attractive), but also the &lt;strong&gt;Stunty&lt;/strong&gt; trait, making long distance passes more risky, decreasing the average passing distance).&lt;/p&gt;
&lt;p&gt;Finally, which teams are similar depends on which plot we look at! Take for example the &lt;strong&gt;Black Orc&lt;/strong&gt; team: Based on fouling and distance passed (Bottom left plot), it is very similar to the four &lt;strong&gt;Stunty&lt;/strong&gt; teams. However, In the plot that combines Fouls and Blocks (lower right), it suddenly becomes unique!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;pca-versus-clustered-heatmaps&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;PCA versus clustered heatmaps&lt;/h1&gt;
&lt;p&gt;So how can we compare the teams on all stats simultaneously? We can try to reduce the number of variables by looking at correlations between variables. For example, we observed a strong (negative) correlation between the number of blocks and the number of passes. We could take these two variables together and map (“project”) each team on a single new “axis” (the straight line in the top left plot). For this a commonly used technique is PCA (“principal component analysis”). The original variables are combined into “principle components” along which the most variation occurs. A nufflytics blog post by &lt;strong&gt;Schlice&lt;/strong&gt; &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-schlice18a&#34; role=&#34;doc-biblioref&#34;&gt;Schlice 2018&lt;/a&gt;)&lt;/span&gt; applies this technique to classify the Blood Bowl teams of the online &lt;strong&gt;Blood Bowl 2&lt;/strong&gt; variant of the game. Another example of this approach is &lt;a href=&#34;https://www.diva-portal.org/smash/get/diva2:1541669/FULLTEXT02.pdf&#34;&gt;the master thesis project of Tadas Ivanauskas&lt;/a&gt; &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-ivanauskas20&#34; role=&#34;doc-biblioref&#34;&gt;Ivanauskas 2020&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;With PCA, a common approach is to focus on the first two principal components, as these can be visualized on a 2D coordinate system (i.e. a scatter plot). However, a big disadvantage of PCA is that the new dimensions are difficult to interpret, because the original data is transformed and combined, and therefore no longer recognizable. In the above mentioned blog post, this becomes apparent when the author puts in serious effort to understand the first four principal components, see &lt;a href=&#34;https://www.nufflytics.com/post/bash-dash-hybrid-diving-deeper/&#34;&gt;his “diving deeper” follow up post&lt;/a&gt;. Because each component is a (different) linear combination of ALL 17 variables (!), interpreting the principal components becomes very difficult. To do so requires a high cognitive load, and it is unclear where the signal ends and noise starts.&lt;/p&gt;
&lt;p&gt;An attractive alternative is performing a cluster analysis on the original data, and using the cluster order to directly visualize the data as a heatmap. This technique is called &lt;strong&gt;clustered heatmaps&lt;/strong&gt;, and is widely used in bioinformatics to display patterns in data.&lt;/p&gt;
&lt;p&gt;Two of the most popular clustering algorithms are &lt;strong&gt;Hierarchical clustering&lt;/strong&gt; and &lt;strong&gt;k-means clustering&lt;/strong&gt;. For example we can ask the computer to cluster the 28 teams into e.g. 5 clusters using the K-means algorithm. This assigns each team to one of &lt;span class=&#34;math inline&#34;&gt;\(k = 5\)&lt;/span&gt; clusters, with the cluster centers chosen such that teams within a cluster are close by the cluster center and far away from the other cluster centers. However, this forces us to pick the number of clusters, AND it does not provide information on team similarity WITHIN a cluster.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;clustered-heatmaps-for-the-win&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Clustered heatmaps for the win&lt;/h1&gt;
&lt;p&gt;Hierarchical clustering circumvents both drawbacks as it clusters ALL the observations in such a way that the most similar observations end up next to each other, and thus provide a complete ordering of all observations. All that remains is to plot the data in this order on a colored grid, and BAM the patterns hit us right between the eyes!&lt;/p&gt;
&lt;p&gt;The basic functionality to make a heatmap is provided in the R package &lt;code&gt;ggplot2&lt;/code&gt; by the &lt;code&gt;geom_tile()&lt;/code&gt; geometric object.
Many wrapper functions around &lt;code&gt;geom_tile()&lt;/code&gt; exist to make clustered heatmaps, however they all combine the clustering step with the plotting step.&lt;/p&gt;
&lt;p&gt;I am currently experimenting with my own wrapper function &lt;code&gt;ggorder_heatmap()&lt;/code&gt;, which I turned into an R package called &lt;code&gt;ggoheatmap&lt;/code&gt;. See for details the GitHub repository for &lt;a href=&#34;https://github.com/gsverhoeven/ggoheatmap&#34;&gt;the ggoheatmap R package&lt;/a&gt;.
Note that it is unstable, under development, and possible not even a good idea, so do not use it yourself.
Instead use &lt;code&gt;pheatmap&lt;/code&gt; by Raivo Kolde, available from CRAN, with the official repo &lt;a href=&#34;https://github.com/raivokolde/pheatmap&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggoheatmap)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;varnames &amp;lt;- c(&amp;quot;Blocks&amp;quot;, &amp;quot;Fouls&amp;quot;, &amp;quot;Cas_inflicted&amp;quot;,  &amp;quot;Distance_passed&amp;quot;, &amp;quot;Completions&amp;quot;, &amp;quot;Running_w_ball&amp;quot;, &amp;quot;Cas_suffered&amp;quot;)
yorder &amp;lt;- data.frame(yorder = 1:length(varnames), variable = varnames)

df_long &amp;lt;- df_agg %&amp;gt;%
  pivot_longer(cols = !c(race_name, race_type, size), names_to = &amp;quot;variable&amp;quot;) %&amp;gt;%
  group_by(variable) %&amp;gt;%
  mutate(sd_value = scale(value)) %&amp;gt;%
  left_join(yorder, by = &amp;quot;variable&amp;quot;)

df_long &amp;lt;- ggoheatmap::hclust_order(df_long, 
                        xvar = &amp;quot;race_name&amp;quot;, 
                        yvar = &amp;quot;variable&amp;quot;, 
                        value_var = &amp;quot;value&amp;quot;,
                   clust_method = &amp;quot;complete&amp;quot;,
                   dist_method = &amp;quot;euclidean&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(patchwork)

p1 &amp;lt;- ggplot(df_long, aes(x = reorder(race_name, cluster_order), y = 1, fill = race_type)) +
  geom_tile() + 
  coord_flip() + 
  labs(x = &amp;quot;&amp;quot;, y = NULL) + 
  scale_y_discrete(labels = NULL, breaks = NULL) 

p2 &amp;lt;- ggorder_heatmap(df_long, 
                xvar = &amp;quot;race_name&amp;quot;, 
                yvar = &amp;quot;variable&amp;quot;, 
                col_var = &amp;quot;sd_value&amp;quot;, 
                order_var = &amp;quot;cluster_order&amp;quot;,
                yorder_var =&amp;quot;yorder&amp;quot;,
                legend = FALSE,
                label_var = &amp;quot;value&amp;quot;, round.digits = 1) + coord_flip() +
  scale_y_discrete(position = &amp;quot;right&amp;quot;)

p1 + p2 + 
  plot_layout(widths = c(1, 6), guides = &amp;quot;collect&amp;quot;) + 
  plot_annotation(title = &amp;#39;BB2020 team typology&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-11-01_clustered_heatmaps_blood_bowl_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;1344&#34; /&gt;
And there we have it, our main result.&lt;/p&gt;
&lt;p&gt;First, we see that the existing team categorization does a good job, with the different categories showing different patterns in the match statistics.
Note that I did not pre-specify the sort order here, it emerged naturally from the match statistics by the hierarchical clustering algorithm. So the quote from the Pi movie was correct (at least for Blood Bowl): we graphed the numbers, and patterns emerged!&lt;/p&gt;
&lt;p&gt;What else can we learn from this plot?
The difference between Bash and Hybrid appears not so clear cut: for example: Are Norse (the old BB2020 roster, not the new one) and Chaos Chosen bash or hybrid?
Agile and Stunty teams on the other hand are very distinct.
Underworld Denizens are an interesting edge case:
In BB2020, they cluster right in between Goblin and Skaven teams, I ended up classifying them as Agile.
Finally, it is apparent that Vampires indeed are a category of their own.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;And now for the question we set out to answer: Where do the new Khorne and Black Orc teams fit in?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Khorne&lt;/strong&gt; are clearly a hybrid team (because of the lack of skills and frenzy reduces base contact and thus blocks).
&lt;strong&gt;Black Orcs&lt;/strong&gt; appear to be quite unique, being a combination of Bashy Hybrid and Fouling.&lt;/p&gt;
&lt;p&gt;Finally we produce the clustered heatmap for all four divisions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;source(&amp;quot;heatmap_post/make_heatmap.R&amp;quot;)

for(i in 1:length(divisions)){
  print(make_heatmap(data_tables[[divisions[i]]], division_name = divisions[i]))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-11-01_clustered_heatmaps_blood_bowl_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;1152&#34; /&gt;&lt;img src=&#34;/post/2022-11-01_clustered_heatmaps_blood_bowl_files/figure-html/unnamed-chunk-14-2.png&#34; width=&#34;1152&#34; /&gt;&lt;img src=&#34;/post/2022-11-01_clustered_heatmaps_blood_bowl_files/figure-html/unnamed-chunk-14-3.png&#34; width=&#34;1152&#34; /&gt;&lt;img src=&#34;/post/2022-11-01_clustered_heatmaps_blood_bowl_files/figure-html/unnamed-chunk-14-4.png&#34; width=&#34;1152&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references csl-bib-body hanging-indent&#34;&gt;
&lt;div id=&#34;ref-amiral17&#34; class=&#34;csl-entry&#34;&gt;
Amiral, Taureau. 2017. &lt;span&gt;“Blood Bowl Teams Strength.”&lt;/span&gt; &lt;em&gt;Blood Bowl Strategies&lt;/em&gt; (blog). November 24, 2017. &lt;a href=&#34;https://bloodbowlstrategies.com/en/relative-strength-of-teams/&#34;&gt;https://bloodbowlstrategies.com/en/relative-strength-of-teams/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-breidr15&#34; class=&#34;csl-entry&#34;&gt;
Breidr. 2015. &lt;span&gt;“Cyanide - &lt;span&gt;‘Bashy’&lt;/span&gt; Race Choice for League Play.”&lt;/span&gt; Blood Bowl Tactics Forum. 2015. &lt;a href=&#34;https://bbtactics.com/forum/threads/bashy-race-choice-for-league-play.4961/&#34;&gt;https://bbtactics.com/forum/threads/bashy-race-choice-for-league-play.4961/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-dode17&#34; class=&#34;csl-entry&#34;&gt;
Dode. 2017. &lt;span&gt;“What Is the Bashiest Agility Team After Dark Elves? :: Blood Bowl 2 General Discussions.”&lt;/span&gt; 2017. &lt;a href=&#34;https://steamcommunity.com/app/236690/discussions/0/135512931355543270/&#34;&gt;https://steamcommunity.com/app/236690/discussions/0/135512931355543270/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-ivanauskas20&#34; class=&#34;csl-entry&#34;&gt;
Ivanauskas, Tadas. 2020. &lt;em&gt;BloodBowl 2 race clustering by different playstyles&lt;/em&gt;. &lt;a href=&#34;http://urn.kb.se/resolve?urn=urn:nbn:se:mau:diva-41540&#34;&gt;http://urn.kb.se/resolve?urn=urn:nbn:se:mau:diva-41540&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-schlice18a&#34; class=&#34;csl-entry&#34;&gt;
Schlice. 2018. &lt;span&gt;“Bash/Dash/Hybrid by the Numbers.”&lt;/span&gt; February 27, 2018. &lt;a href=&#34;http://www.nufflytics.com/post/bash-dash-hybrid-by-the-numbers/&#34;&gt;http://www.nufflytics.com/post/bash-dash-hybrid-by-the-numbers/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-wilkinson_friendly09&#34; class=&#34;csl-entry&#34;&gt;
Wilkinson, Leland, and Michael Friendly. 2009. &lt;span&gt;“The History of the Cluster Heat Map.”&lt;/span&gt; &lt;em&gt;The American Statistician&lt;/em&gt; 63 (2): 179–84. &lt;a href=&#34;https://doi.org/10.1198/tas.2009.0033&#34;&gt;https://doi.org/10.1198/tas.2009.0033&lt;/a&gt;.
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Nufflytics: Analyzing Blood Bowl matches from FUMBBL using Python</title>
      <link>/post/blood-bowl-nufflytics/</link>
      <pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate>
      <guid>/post/blood-bowl-nufflytics/</guid>
      <description>


&lt;p&gt;This blogpost is about &lt;strong&gt;Blood Bowl&lt;/strong&gt;, a strategic boardgame invented in the late 80’s, that I finally started playing last year. Blood bowl is a game of Fantasy Football, where fantasy team races (think “Orcs”, or “Elves”) are pitted against each other. Interestingly, the various teams (there are over 20 different ones) require different play styles, and not all team races are equally strong. On tournaments, this gives rise to various compensation schemes to make all teams “viable” for competition. There exists a lively tournament scene, with thousands of matches played each year.&lt;/p&gt;
&lt;p&gt;The idea of this blog post is to showcase some possible analyses that can be done on the &lt;a href=&#34;https://gsverhoeven.github.io/post/blood-bowl-fumbbl-dataset/&#34;&gt;FUMBBL match data I’ve compiled&lt;/a&gt;. The idea is to make Blood Bowl data analysis (also know as &lt;a href=&#34;https://nufflytics.com&#34;&gt;Nufflytics&lt;/a&gt;, a term coined by Blood Bowler “Schlice” in reference to Nuffle, the god of Blood Bowl) easier and more accessible to others. I took inspiration from various sources, detailed at the end of this post. So lets dive in the world of Blood Bowl stats nerdery.&lt;/p&gt;
&lt;div id=&#34;getting-started-with-the-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Getting started with the data&lt;/h1&gt;
&lt;p&gt;Since the previous blog post on FUMBBL data, I decided to make a separate Github repository &lt;a href=&#34;https://github.com/gsverhoeven/fumbbl_datasets&#34;&gt;fumbbl_datasets&lt;/a&gt; that contains the Python code to fetch and construct the FUMBBL datasets. You can either download the latest datasets manually, or clone the entire repo to your local drive, depending on your expertise and preferences.&lt;/p&gt;
&lt;p&gt;The datasets are available both in CSV and HDF5. CSV would be the format of choice for Excel analysis, whereas the HDF5 format is suitable for scripted languages such as Python or R. Here we use Python, with the libraries &lt;code&gt;Pandas&lt;/code&gt; and &lt;code&gt;plotnine&lt;/code&gt; for data analysis and visualization. The code below assumes the datasets are locally stored at the location contained in the &lt;code&gt;path_to_datasets&lt;/code&gt; variable:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import pandas as pd
import numpy as np
import plotnine as p9

# point this to the location of the HDF5 datasets
path_to_datasets = &amp;#39;../../../../fumbbl_datasets/&amp;#39;

# FUMBBL matches
target = &amp;#39;datasets/v0.2/df_matches.h5&amp;#39;
df_matches = pd.read_hdf(path_to_datasets + target) 

# FUMBBL matches by team
target = &amp;#39;datasets/v0.2/df_mbt.h5&amp;#39;
df_mbt = pd.read_hdf(path_to_datasets + target) 

# FUMBBL inducements
target = &amp;#39;datasets/v0.2/inducements.h5&amp;#39;
inducements = pd.read_hdf(path_to_datasets + target) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;what-data-do-we-have-weekly-game-volumes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What data do we have? Weekly game volumes&lt;/h1&gt;
&lt;p&gt;Let’s see what we’ve got! The pandas DataFrame &lt;code&gt;df_matches&lt;/code&gt; contains records for all matches played on FUMBBL between august 2020 and march 2022.&lt;/p&gt;
&lt;p&gt;Since we have a proper &lt;code&gt;datetime&lt;/code&gt; type variable for each week (&lt;code&gt;week_date&lt;/code&gt;), we can use &lt;code&gt;pandas&lt;/code&gt; and &lt;code&gt;plotnine&lt;/code&gt; to plot the weekly game volume as a time series.&lt;/p&gt;
&lt;p&gt;The introduction of the new &lt;strong&gt;Competitive division&lt;/strong&gt; with BB2020 rules is marked by a vertical red line. I labeled the larger leagues as well a recent tournament I took part in myself.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;res = (df_matches
    .loc[(df_matches[&amp;#39;week_date&amp;#39;] &amp;gt;= &amp;#39;2020-08-01&amp;#39; ) &amp;amp; (df_matches[&amp;#39;week_date&amp;#39;] &amp;lt; &amp;#39;2022-11-25&amp;#39;)]
    .groupby([&amp;#39;week_date&amp;#39;, &amp;#39;week_number&amp;#39;, &amp;#39;division_name&amp;#39;])
    .agg(        
        n_games = (&amp;#39;match_id&amp;#39;, &amp;quot;count&amp;quot;) 
    )
    .reset_index()) # this adds the &amp;quot;group by&amp;quot; variables back as columns of res

(p9.ggplot(data = res, mapping = p9.aes(x = &amp;#39;week_date&amp;#39;, y = &amp;#39;n_games&amp;#39;, color = &amp;#39;division_name&amp;#39;))
+ p9.geom_point() 
+ p9.geom_line()
+ p9.expand_limits(y=[0,2000])
+ p9.geom_vline(xintercept = &amp;#39;2021-09-01&amp;#39;, color = &amp;quot;red&amp;quot;)
+ p9.theme(figure_size = (10, 5))
+ p9.ggtitle(&amp;quot;Weekly game volume on FUMBBL august 2020 - march 2022&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-03-20_nufflytics_blog_post_files/nufflytics_blog_post_4_0.png&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ggplot: (-9223363302253724542)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To check the dataset, I compared this plot with the plot of weekly game volumes that FUMBBL itself provides at &lt;a href=&#34;https://fumbbl.com/p/stats&#34; class=&#34;uri&#34;&gt;https://fumbbl.com/p/stats&lt;/a&gt;.
Both plots looked identical at the time of writing, so it seems that we have a complete dataset for the given period.&lt;/p&gt;
&lt;p&gt;The effect of starting the new BB2020 Competitive division is clearly visible, with the weekly game volume almost doubling in september 2021.
The first online NAF tournament using BB2020 rules is also visible, running for 6 weeks in October / November 2021.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;star-player-usage-on-fumbbl&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Star player usage on FUMBBL&lt;/h1&gt;
&lt;p&gt;We can also look at the percentage of matches that involve star players.
I used the various plot aesthetics like symbol shape and size to encode the game volume and ruleset (BB2016 or BB2020 based).&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;divisions = [&amp;#39;Blackbox&amp;#39;, &amp;#39;Competitive&amp;#39;, &amp;#39;Online NAF Tournaments&amp;#39;,  &amp;#39;Ranked&amp;#39;, &amp;#39;Regular_league&amp;#39;]

res = (df_matches
.query(&amp;quot;division_name in @divisions&amp;quot;)
.groupby([&amp;#39;division_name&amp;#39;, &amp;#39;league&amp;#39;, &amp;#39;ruleset&amp;#39;, &amp;#39;ruleset_version&amp;#39;, &amp;#39;week_date&amp;#39;])
.agg(
    n_games = (&amp;#39;match_id&amp;#39;, &amp;#39;count&amp;#39;),
    perc_sp = (&amp;#39;has_sp&amp;#39;, &amp;#39;mean&amp;#39;)
)
.reset_index()
.sort_values(&amp;quot;n_games&amp;quot;, ascending=False)
)

(p9.ggplot(data = res.query(&amp;quot;n_games &amp;gt; 30&amp;quot;), mapping = p9.aes(x = &amp;#39;week_date&amp;#39;, y = &amp;#39;perc_sp*100&amp;#39;, 
group = &amp;#39;factor(division_name)&amp;#39;, color = &amp;#39;factor(division_name)&amp;#39;))
    + p9.geom_point(p9.aes(shape = &amp;#39;factor(ruleset_version)&amp;#39;, size = &amp;#39;n_games&amp;#39;)) 
    + p9.expand_limits(y=[0,1])
    + p9.scale_size_area()
    + p9.geom_vline(xintercept = &amp;#39;2021-09-01&amp;#39;, color = &amp;quot;red&amp;quot;)
    + p9.ggtitle(&amp;quot;Star player usage over time, by division/league&amp;quot;)
    + p9.theme(figure_size = (10, 6))
    + p9.ylab(&amp;quot;% matches with at least one Star Player&amp;quot;))
    &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-03-20_nufflytics_blog_post_files/nufflytics_blog_post_7_0.png&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ggplot: (-9223363302246313763)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In above graph, the various online NAF Tournaments are clearly distinguished. &lt;strong&gt;Amorical Cup 2020&lt;/strong&gt; in summer 2020, &lt;strong&gt;Eur’Open Online&lt;/strong&gt; in Nov/dec 2020, &lt;strong&gt;SteelBowl&lt;/strong&gt; in Feb 2021, and &lt;strong&gt;LitBowl&lt;/strong&gt; in May 2021 were all using BB2016 rules.&lt;/p&gt;
&lt;p&gt;Through Googling and using the Wayback Machine, I was able to find the rulepacks of these tournaments. LitBowl featured “big budgets” (up to 1440K) and a requirement of only 10 regular players before inducement, this likely explains the large amount of Star Players in that tournament.&lt;/p&gt;
&lt;p&gt;In contrast, in the GBFU tournament, the first online NAF tournament using the BB2020 rules, only some 15% of matches involved at least one star player.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;are-coach-ratings-predictive-of-match-outcomes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Are coach ratings predictive of match outcomes?&lt;/h1&gt;
&lt;p&gt;For the main divisions on FUMBBL, ELO style coach ratings are available that are updated after each game.
The coach rankings are explained on &lt;a href=&#34;https://fumbbl.com/help:Ranking&#34;&gt;this help page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;According to the ELO ranking system, a coach rating difference of 40 should result in 85% wins for the higher ranked coach.
Coaches of equal rating should have a win rate of 0.5 (with draws weighted at half point).&lt;/p&gt;
&lt;p&gt;The range of coach rankings observed for a particular game tells us something about the relationship between skill and luck.
If a game is pure luck, we will never observe large differences in coach rating, since the outcome will be determined by a coin flip, independent of coach skill.&lt;/p&gt;
&lt;p&gt;On FUMBBL, coach ratings vary roughly between 125 and 175. What do we expect if a coach with a rating of 175 plays a coach of rating 145? Well, the rating difference is 30. According to the formula (assuming equal team strength and equal races), the expected win probability is 1/(1 + 10^0.75) = 85%, and the probability of loss is 15%.&lt;/p&gt;
&lt;p&gt;Since our CR we obtained from the FUMBBL match result page is an overall coach rating (i.e. it ignores division), we can simply pool all matches from divisions where coach rating is tracked.&lt;/p&gt;
&lt;p&gt;The match data contains a &lt;strong&gt;Coach Ranking Difference&lt;/strong&gt; bin (category) that we can each to calculate the Win/draw/loss percentages for each category.&lt;/p&gt;
&lt;p&gt;Let’s see what the actual percentages are:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;main_divisions = [&amp;#39;Blackbox&amp;#39;, &amp;#39;Ranked&amp;#39;, &amp;#39;Competitive&amp;#39;]

res = (df_matches[df_matches[&amp;#39;division_name&amp;#39;].isin(main_divisions)]
    .groupby([&amp;#39;cr_bin&amp;#39;, &amp;#39;team1_win&amp;#39;])
    .agg(        
        n_games = (&amp;#39;cr_bin&amp;#39;, &amp;quot;count&amp;quot;),
    )
    .reset_index()) # this adds the group by variable (now index) as a column

# add total games played within each bin
res[&amp;#39;n_games_bin&amp;#39;] = res.groupby(&amp;#39;cr_bin&amp;#39;).n_games.transform(&amp;#39;sum&amp;#39;)

res[&amp;#39;perc&amp;#39;] = res[&amp;#39;n_games&amp;#39;]/res[&amp;#39;n_games_bin&amp;#39;]

(p9.ggplot(res, p9.aes(x = &amp;#39;factor(cr_bin)&amp;#39;, y = &amp;#39;perc&amp;#39;, fill = &amp;#39;factor(team1_win)&amp;#39;)) 
    + p9.geom_bar(position = &amp;quot;fill&amp;quot;, stat = &amp;quot;identity&amp;quot;) 
    + p9.theme(axis_text_x= p9.element_text(rotation=90, hjust=1))
    + p9.ggtitle(&amp;#39;probability of win/draw/loss as a function of Coach Rating difference&amp;#39;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-03-20_nufflytics_blog_post_files/nufflytics_blog_post_10_0.png&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ggplot: (-9223363302350291624)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note that I made the bins for large CR differences (greater than 10) wider to get more games per bin.)&lt;/p&gt;
&lt;p&gt;From above graphs, we can conclude that the coach ratings work as expected, with large coach rating differences indeed showing high win rates for the higher ranked coach. From this we can infer that a highly skilled coach will win 9 times out of ten agains a below average coach. We call Blood Bowl a Strategy game for a reason!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;what-about-the-passing-game-in-bb2020&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What about the passing game in BB2020?&lt;/h1&gt;
&lt;p&gt;With Blood Bowl 2020 also came a large change to passing the ball. Passing is no longer linked to the &lt;strong&gt;Agility&lt;/strong&gt; statistics, but now has its own &lt;strong&gt;Passing&lt;/strong&gt; (PA) stat. Overall, passing became riskier, and high agility teams do not automatically have good passing stats. For example, only a High Elf thrower has a PA of 2+, whereas the rest of the players have a PA of 4+ or higher. On the Dark Elf team, the player with the best PA stat is the runner, with a PA of 3+, without a built in re-roll. So we can expect quite some changes in the number of completions per match. For more detail I refer to a nice post by king_ghidra at &lt;a href=&#34;https://bloodbowlstrategies.com/en/tactics-blood-bowl-second-season/&#34;&gt;Blood Bowl Strategies&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s have a look!&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;divisions = [&amp;#39;Ranked&amp;#39;, &amp;#39;Blackbox&amp;#39;, &amp;#39;Competitive&amp;#39;]

tv_bins = [&amp;#39;1.1M&amp;#39;, &amp;#39;1.4M&amp;#39;, &amp;#39;1.7M&amp;#39;]

res = (df_mbt[df_mbt[&amp;#39;division_name&amp;#39;].isin(divisions)]
    .loc[df_mbt[&amp;#39;tv_bin&amp;#39;].isin(tv_bins)]
    .query(&amp;quot;mirror_match == 0 &amp;amp; has_sp == 0 &amp;amp; tv_bin in @tv_bins &amp;amp; division_name in @divisions&amp;quot;)
    .groupby([&amp;#39;division_name&amp;#39;, &amp;#39;ruleset_version&amp;#39;, &amp;#39;week_date&amp;#39;, &amp;#39;tv_bin&amp;#39;])
    .agg(        
        avg_comp = (&amp;#39;home_comp&amp;#39;, &amp;quot;mean&amp;quot;),
        avg_pass = (&amp;#39;home_pass&amp;#39;, &amp;quot;mean&amp;quot;),
        avg_foul = (&amp;#39;home_foul&amp;#39;, &amp;quot;mean&amp;quot;),
        avg_block = (&amp;#39;home_block&amp;#39;, &amp;quot;mean&amp;quot;),    
        avg_cas = (&amp;#39;home_cas&amp;#39;, &amp;quot;mean&amp;quot;),  
        avg_rcv_cas = (&amp;#39;away_cas&amp;#39;, &amp;quot;mean&amp;quot;),
        n_games = (&amp;#39;race_name&amp;#39;, &amp;quot;count&amp;quot;)
    )
    .sort_values( &amp;#39;n_games&amp;#39;, ascending = False)
    .reset_index()) # this adds the group by variables (now index) as a column

res = res.dropna()

(p9.ggplot(data = res.query(&amp;#39;n_games &amp;gt; 10&amp;#39;), 
            mapping = p9.aes(x = &amp;#39;week_date&amp;#39;, y = &amp;#39;avg_comp&amp;#39;, 
                            size = &amp;#39;n_games&amp;#39;, color = &amp;#39;factor(division_name)&amp;#39;, shape = &amp;#39;factor(tv_bin)&amp;#39;))
    + p9.geom_point()
    + p9.scale_size_area() 
    + p9.geom_vline(xintercept = &amp;#39;2021-09-01&amp;#39;, color = &amp;quot;red&amp;quot;)    
    + p9.theme(figure_size = (10, 5))
    + p9.ggtitle(&amp;quot;average completions per game BB2020 vs BB2016&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/home/gertjan/venvs/requests_env/lib/python3.6/site-packages/plotnine/scales/scale_shape.py:85: PlotnineWarning: Using shapes for an ordinal variable is not advised.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-03-20_nufflytics_blog_post_files/nufflytics_blog_post_13_1.png&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ggplot: (-9223363302350371093)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;divisions = [&amp;#39;Ranked&amp;#39;, &amp;#39;Blackbox&amp;#39;, &amp;#39;Competitive&amp;#39;]

tv_bins = [&amp;#39;1.1M&amp;#39;, &amp;#39;1.4M&amp;#39;, &amp;#39;1.7M&amp;#39;]

res = (df_mbt[df_mbt[&amp;#39;division_name&amp;#39;].isin(divisions)]
    .loc[df_mbt[&amp;#39;tv_bin&amp;#39;].isin(tv_bins)]
    .query(&amp;quot;mirror_match == 0 &amp;amp; has_sp == 0 &amp;amp; tv_bin in @tv_bins &amp;amp; division_name in @divisions&amp;quot;)
    .groupby([&amp;#39;ruleset_version&amp;#39;, &amp;#39;race_name&amp;#39;, &amp;#39;tv_bin&amp;#39;])
    .agg(        
        avg_comp = (&amp;#39;home_comp&amp;#39;, &amp;quot;mean&amp;quot;),
        avg_pass = (&amp;#39;home_pass&amp;#39;, &amp;quot;mean&amp;quot;),
        avg_foul = (&amp;#39;home_foul&amp;#39;, &amp;quot;mean&amp;quot;),
        n_games = (&amp;#39;race_name&amp;#39;, &amp;quot;count&amp;quot;)
    )
    .sort_values( &amp;#39;n_games&amp;#39;, ascending = False)
    .reset_index()) # this adds the group by variables (now index) as a column

res = res.dropna()

(p9.ggplot(data = res.query(&amp;#39;n_games &amp;gt; 10 &amp;amp; tv_bin == &amp;quot;1.1M&amp;quot;&amp;#39;), 
            mapping = p9.aes(y = &amp;#39;reorder(race_name, avg_comp)&amp;#39;, x = &amp;#39;avg_comp&amp;#39;, 
                            size = &amp;#39;n_games&amp;#39;, group = &amp;#39;factor(ruleset_version)&amp;#39;, 
                            color = &amp;#39;factor(ruleset_version)&amp;#39;))
    + p9.geom_point()
    + p9.scale_size_area() 
    + p9.ggtitle(&amp;quot;average completions per game BB2016 vs BB2020 at 1.1M TV&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-03-20_nufflytics_blog_post_files/nufflytics_blog_post_14_0.png&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ggplot: (-9223363302350232432)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Across the board we see a decrease in average completions per match. Note that this is for low team values, at around 1.1M, between 950K and 1250K.&lt;/p&gt;
&lt;p&gt;Observations that stand out:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;High agility teams such as Elven Union, Wood Elf and Skaven show large drops,&lt;/li&gt;
&lt;li&gt;Dark elves show the largest relative drop (more than halving in completions),&lt;/li&gt;
&lt;li&gt;High Elves are hardly affected, as well as Humans,&lt;/li&gt;
&lt;li&gt;Halflings show a large increase.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;and-what-about-fouling-in-bb2020&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;And what about fouling in BB2020?&lt;/h1&gt;
&lt;p&gt;Also for fouling Blood Bowl 2020 brought some changes to the rules. The &lt;strong&gt;Sneaky Git&lt;/strong&gt; skill became better, allowing a player to continue moving after the foul has been committed. The &lt;strong&gt;Black Orcs&lt;/strong&gt; were added as a new team, that show fouling potential: they have access to cheap bribes, the &lt;strong&gt;Grab&lt;/strong&gt; skill to set up a foul, and cheap goblin bruisers to quickly move around the pitch. And there was of course the &lt;strong&gt;swarming&lt;/strong&gt; for the Underworld and Snotling teams, that provides a continuous supply of disposable players to foul with. For more detail I refer to a nice post by king_ghidra at &lt;a href=&#34;https://bloodbowlstrategies.com/en/tactics-blood-bowl-second-season/&#34;&gt;Blood Bowl Strategies&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s see how the stats were affected!&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;divisions = [&amp;#39;Ranked&amp;#39;, &amp;#39;Blackbox&amp;#39;, &amp;#39;Competitive&amp;#39;]

tv_bins = [&amp;#39;1.1M&amp;#39;, &amp;#39;1.2M&amp;#39;, &amp;#39;1.3M&amp;#39;, &amp;#39;1.4M&amp;#39;]

res = (df_mbt[df_mbt[&amp;#39;division_name&amp;#39;].isin(divisions)]
    .loc[df_mbt[&amp;#39;tv_bin2&amp;#39;].isin(tv_bins)]
    .query(&amp;quot;mirror_match == 0 &amp;amp; has_sp == 0 &amp;amp; tv_bin2 in @tv_bins &amp;amp; division_name in @divisions&amp;quot;)
    .groupby([&amp;#39;ruleset_version&amp;#39;, &amp;#39;race_name&amp;#39;, &amp;#39;tv_bin2&amp;#39;])
    .agg(        
        avg_comp = (&amp;#39;home_comp&amp;#39;, &amp;quot;mean&amp;quot;),
        avg_pass = (&amp;#39;home_pass&amp;#39;, &amp;quot;mean&amp;quot;),
        avg_foul = (&amp;#39;home_foul&amp;#39;, &amp;quot;mean&amp;quot;),
        n_games = (&amp;#39;race_name&amp;#39;, &amp;quot;count&amp;quot;)
    )
    .sort_values( &amp;#39;n_games&amp;#39;, ascending = False)
    .reset_index()) # this adds the group by variables (now index) as a column

res = res.dropna()

(p9.ggplot(data = res.query(&amp;#39;n_games &amp;gt; 10&amp;#39;), 
            mapping = p9.aes(y = &amp;#39;reorder(race_name, avg_foul)&amp;#39;, x = &amp;#39;avg_foul&amp;#39;, 
                            size = &amp;#39;n_games&amp;#39;, color = &amp;#39;factor(ruleset_version)&amp;#39;, 
                            shape = &amp;#39;factor(tv_bin2)&amp;#39;))
    + p9.geom_point()
    + p9.scale_size_area() 
    + p9.ggtitle(&amp;quot;average number of fouls per game BB2016 vs BB2020&amp;quot;)
    + p9.ylab(&amp;quot;&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-03-20_nufflytics_blog_post_files/nufflytics_blog_post_17_1.png&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ggplot: (8734504437775)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this plot, we can see that BB2020 indeed shows increased fouling across the board. As expected, the Black Orcs are high up in the fouling charts, and we see large increases in fouling for Underworld, Goblins, Halflings and Snotlings. We can also see that as teams develop, fouling typically increases, possible related to developing a specialized fouling player with the sneaky git skill. For humans access to cheap agile halfling hopefulls with access to sneaky git increased fouling opportunity. In Orc teams goblins can forfill this role.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;competitive-division-win-rates-and-malta-eurobowl-2022-tiers&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Competitive division win rates and Malta Eurobowl 2022 tiers&lt;/h1&gt;
&lt;p&gt;Last but not least, a win rate analysis. In a tournament setting, elaborate tiering systems are in place to compensate for differences in race strength, skills are selected from skill packs, and player casualties are forgotten with each match played with a “resurrected” fresh team. Furthermore, opponents are randomly assigned and must be played. Contrast this with the FUMBBL Competitive division: Here teams start with 1M gold and without any extra skills. Teams must be developed, like in a league, and opponents can be strategically chosen based on which race they play, their coach rating etc.&lt;/p&gt;
&lt;p&gt;With all this in mind, I tried the impossible: to compare relative team strength as expected by the tournament tiers, with the observed win rates in the Competitive Division. With the Eurobowl 2022 in Malta coming up, I decided to approximate the conditions of that rulepack. Teams are created using 1.15M gold, as well as roughly 36 SPP worth of skills. This translates to 6 primary skills worth 20K, giving us a total team value of 1270K, say around 1.3M.&lt;/p&gt;
&lt;p&gt;To correct for differences in coaching ability, I restricted the match selection for matches where coach ratings are not too different (&amp;lt; 10), and above 150. I excluded matches involving Star players, and mirror matches (I.e. Orcs vs Orcs).
To distinguish the relatively small % differences in win rate, we need to have a bandwidth around 1.3M to get sufficient statistics for each team.
I included confidence intervals to visualize the statistical uncertainty for the win rates.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# Function for computing confidence intervals
from statsmodels.stats.proportion import proportion_confint   

divisions = [&amp;#39;Competitive&amp;#39;]

tv_bins = [&amp;#39;1.2M&amp;#39;, &amp;#39;1.3M&amp;#39;, &amp;#39;1.4M&amp;#39;]

res = (df_mbt[df_mbt[&amp;#39;division_name&amp;#39;].isin(divisions)]
    .loc[df_mbt[&amp;#39;tv_bin2&amp;#39;].isin(tv_bins)]
    .query(&amp;#39;mirror_match == 0 &amp;amp; has_sp == 0 &amp;amp; CR_diff &amp;lt; 10 &amp;amp; coach_CR &amp;gt; 150&amp;#39;)
    .groupby([&amp;#39;race_name&amp;#39;, &amp;#39;ruleset_version&amp;#39;, &amp;#39;Malta_2022&amp;#39;])
    .agg(        
        perc_win = (&amp;#39;wins&amp;#39;, &amp;quot;mean&amp;quot;),
        n_wins = (&amp;#39;wins&amp;#39;, &amp;quot;sum&amp;quot;),
        n_games = (&amp;#39;race_name&amp;#39;, &amp;quot;count&amp;quot;)
    )
    .query(&amp;#39;n_games &amp;gt; 0&amp;#39;)
    .reset_index()) # this adds the group by variable (now index) as a column

res[&amp;#39;lower_CI&amp;#39;], res[&amp;#39;upper_CI&amp;#39;] =  proportion_confint(
                                      count = round(res[&amp;#39;n_wins&amp;#39;]).astype(int),
                                      nobs = res[&amp;#39;n_games&amp;#39;],
                                      alpha = 0.05
                                  )

(p9.ggplot(data = res.query(&amp;#39;n_games &amp;gt; 30&amp;#39;), 
            mapping = p9.aes(x = &amp;#39;reorder(race_name, -Malta_2022)&amp;#39;, y = &amp;#39;perc_win&amp;#39;, 
            size = &amp;#39;n_games&amp;#39;, color = &amp;#39;factor(Malta_2022)&amp;#39;))
    + p9.geom_linerange(p9.aes(ymin = &amp;#39;lower_CI&amp;#39;, ymax = &amp;#39;upper_CI&amp;#39;), size = 1)
    + p9.geom_point()
    + p9.scale_size_area() 
    + p9.coord_flip()
    + p9.geom_hline(yintercept = 0.5)
    + p9.ggtitle(&amp;quot;FUMBBL BB2020 win rates around 1.3M&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-03-20_nufflytics_blog_post_files/nufflytics_blog_post_20_0.png&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ggplot: (-9223363302334269892)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First off, I think the most important lesson here is that it is really difficult to compare win rates across such different settings.&lt;/p&gt;
&lt;p&gt;But what info can we squeeze from this plot nevertheless:&lt;/p&gt;
&lt;p&gt;It seems that Amazon and Underworld have higher FUMBBL win rates than expected based on their Malta 2022 tier.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For Amazon, this might be due to being able to avoid particular opponents on FUMBBL, such as Dwarves and Chaos Dwarves, with a lot of Tackle.&lt;/li&gt;
&lt;li&gt;For Underworld, this is likely related to their improvements in BB2020, leading the charts at NAF tournaments, that resulted in recent rule changes that weakened them with the November 2021 Games Workshop ruling.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What else do we got:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nurgle has a relatively low win rate compared to other teams with the same tier.&lt;/li&gt;
&lt;li&gt;High Elf has a low tier, but shows an above average win rate, and appears to perform well at NAF tournaments. Curious to see how this race will do this year.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;concluding-remarks-and-acknowledgements&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Concluding Remarks and acknowledgements&lt;/h1&gt;
&lt;p&gt;The analyses above hopefully give you some idea what can be with the rich FUMMBL data available.&lt;/p&gt;
&lt;p&gt;One last application: The data can also be used to search for matches based on highly particular search criteria: for example, if you are interested in Snotling matches that induce Morg N Thorg and play against a skilled Elf coach. The &lt;code&gt;match_id&lt;/code&gt; can then be used to watch the replay on FUMBBL.&lt;/p&gt;
&lt;p&gt;Finally, some acknowledgements. While writing this blog, I drew inspiration from several sources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;most notable the &lt;a href=&#34;https://www.fumbbl.com&#34;&gt;FUMBBL website itself&lt;/a&gt; that has a wealth of statistics available,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://fumbbldata.azurewebsites.net/stats.html&#34;&gt;website of FUMBBL coach Koadah&lt;/a&gt; with aggregated FUMBBL stats,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://public.tableau.com/app/profile/mike.sann0638.davies/viz/TheNAFReport/Games&#34;&gt;NAF monthly reports&lt;/a&gt; by Mike Davies,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;https://bloodbowlstrategies.com/en/relative-strength-of-teams/&#34;&gt;blog post on team strength&lt;/a&gt; by Taureau Amiral ,&lt;/li&gt;
&lt;li&gt;the &lt;a href=&#34;https://nufflytics.com&#34;&gt;Nufflytics blog&lt;/a&gt; by Blood Bowl 2 coach Schlice,&lt;/li&gt;
&lt;li&gt;the various technical posts of &lt;a href=&#34;https://fumbbl.com/~SzieberthAdam&#34;&gt;FUMBBL coach Adam Szieberth&lt;/a&gt; who followed a similar approach using Python API and web scraping FUMBBL data.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>OpenJDK and IcedTea: Java Web Start Forensics on Ubuntu</title>
      <link>/post/ffb_client_java_linux/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      <guid>/post/ffb_client_java_linux/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;To play &lt;a href=&#34;https://www.fumbbl.com&#34;&gt;Blood Bowl online on FUMBBL.com&lt;/a&gt;, a Java client (hereafter “the FFB client”) is used that works with Java Web Start. On my Ubuntu linux systems (18.04LTS and 20.04LTS), open source versions of java and java web start (openJDK and IcedTea) take care of this. This post describes my suffering caused by the client not working anymore after a Ubuntu software update, and might be helpful for others encountering the same issues.&lt;/p&gt;
&lt;p&gt;The suffering started on December 19th 2021, when &lt;code&gt;openJDK&lt;/code&gt; was automatically upgraded, installing a new &lt;code&gt;java.security&lt;/code&gt; file, and left my system unable to run the FUMBBL client using &lt;code&gt;javaws&lt;/code&gt;. Fixing the &lt;code&gt;java.security&lt;/code&gt; file (see below for details) allowed it to start, but it gave me the dreaded &lt;strong&gt;white bar&lt;/strong&gt;, covering part of the chat window and re-roll icons. And the classic &lt;code&gt;unset -v GNOME_DESKTOP_SESSION_ID&lt;/code&gt; did not work anymore!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: After writing the initial version of this post, I learned a bit more.&lt;/p&gt;
&lt;div id=&#34;oracle-openjdk-and-java-8-9-10-17&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Oracle, OpenJDK and Java 8, 9, 10, … 17&lt;/h1&gt;
&lt;p&gt;The FFB client is designed to work well with “Oracle Java 8 from java.com”, see e.g. &lt;a href=&#34;https://fumbbl.com/index.php?name=PNphpBB2&amp;amp;file=viewtopic&amp;amp;t=31365&#34;&gt;here&lt;/a&gt; on FUMBBL.com.&lt;/p&gt;
&lt;p&gt;However, from the current state of affairs, written up &lt;a href=&#34;https://medium.com/@javachampions/java-is-still-free-3-0-0-ocrt-2021-bca75c88d23b&#34;&gt;here by the Java Champions&lt;/a&gt;, I gather that both Oracle Java 8 and OpenJDK 8 come from the same codebase maintained at &lt;a href=&#34;https://openjdk.java.net/&#34;&gt;https://openjdk.java.net/&lt;/a&gt; and that differences are mostly in packaging &amp;amp; support. The release notes for the latest Oracle Java 8 version (8u311) can be found &lt;a href=&#34;https://www.oracle.com/java/technologies/javase/8u311-relnotes.html&#34;&gt;here&lt;/a&gt;. We can see that the bug fixes point to &lt;a href=&#34;https://bugs.openjdk.java.net&#34;&gt;https://bugs.openjdk.java.net&lt;/a&gt; where the bugs are fixed in all affected versions, including openjdk 8.&lt;/p&gt;
&lt;p&gt;I also learned about the different versions of Java. There is 8, but also, 9, 10, 11 etc up to 17.
Of all these versions only 8, 11 and 17 are relevant. Why? Because 8 and 11 are on “Long term support” (LTS), and 17 is the most recent Java version (and also destined to be a LTS version). In the Java champions medium article mentioned above, a nice table is shown with all the different versions and how long they will be supported by the community.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2022-01-04_java_webstart_forensics_ubuntu_files/openjdk_schedule.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Since our goal is to keep on using a Java app written for Java 8, we focus on 8 and 11 for the rest of this post.
Can apps written for Java 8 also be run in a Java 11 environment? In a &lt;a href=&#34;https://medium.com/uptake-tech/migrating-to-java-11-while-maintaining-a-java-8-client-library-f618a3ca6499&#34;&gt;Medium blog post on migrating from Java 8 to Java 11&lt;/a&gt; it is mentioned that Java is famous for its backward compatibility. Indeed, my own experience is that the FFB client can also be run with Java 11.
Which is nice, since Java 11 is currently the default Java version for Ubuntu, and we do not have to install additional software to run the FFB client.&lt;/p&gt;
&lt;p&gt;Finally, there is the web start technology:&lt;/p&gt;
&lt;p&gt;From &lt;a href=&#34;https://en.wikipedia.org/wiki/Java_Web_Start&#34;&gt;wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Java Web Start was distributed as part of the Java Platform, and included in downloads of the JRE and JDK. It was deprecated by Oracle in Java SE 9 and removed in Java SE 11. The code for Java Web Start was not released by Oracle as part of OpenJDK, and thus OpenJDK originally did not support it. IcedTea-Web provides an independent open source implementation of Java Web Start that is currently developed by the AdoptOpenJDK community, RedHat and Karakun AG, and which is bundled in the official OpenJDK installer.[1]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Icedtea is available for both OpenJDK 8 and OpenJDK 11, so no problem there.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;this-blog-post&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;This blog post&lt;/h1&gt;
&lt;p&gt;The “forensics” below were directed to getting Java 8 in the form of openjdk-8 on my Ubuntu systems, and getting the FFB client to run in that Java environement. However, in the meantime I also figured out why the FFB client stopped working on Java 11, and how to fix that.&lt;/p&gt;
&lt;p&gt;From the openJDK schedule above we can see that both Java 8 and 11 in the form of OpenJDK 8 and 11 are supported until sept 2026, so we have at least four more years of online Blood Bowl :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;what-is-up-with-gnome_desktop_session_id&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What is up with GNOME_DESKTOP_SESSION_ID?&lt;/h1&gt;
&lt;p&gt;Ever since I first started playing online Blood Bowl using the FFB client on Ubuntu, I just did the &lt;code&gt;unset -v GNOME_DESKTOP_SESSION_ID&lt;/code&gt; trick and started playing.
However, since the latest &lt;code&gt;openjdk-11&lt;/code&gt;, this stopped working, forcing me to look into it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gertjan:~$ env | grep GNOME_DESK
GNOME_DESKTOP_SESSION_ID=this-is-deprecated&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Ubuntu 20.04LTS, this variable is not even present anymore.&lt;/p&gt;
&lt;p&gt;It turns out that Java tries to detect whether it is on a Gnome / GTK system. If Gnome / GTK is detected, it changes its “Look and feel” of the FFB client: widgets, creating the white bar below, and uses a different font.&lt;/p&gt;
&lt;p&gt;Previously, by unsetting the environment variable &lt;code&gt;GNOME_DESKTOP_SESSION_ID&lt;/code&gt;, we could prevent the client from detecting GTK.
But since the latest openJDK 11 version, there is now a different way in which it detects GTK:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bugs.openjdk.java.net/browse/JDK-8247753&#34; class=&#34;uri&#34;&gt;https://bugs.openjdk.java.net/browse/JDK-8247753&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Java relies on an environment variable GNOME_DESKTOP_SESSION_ID for getting GTK desktop theme. This environmental variable was deprecated earlier and now this got removed in the latest version&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The issue is discussed in detail &lt;a href=&#34;https://github.com/adoptium/adoptium-support/issues/94&#34;&gt;here&lt;/a&gt; on Github.&lt;/p&gt;
&lt;p&gt;The solution the JDK developers went for is to start checking the &lt;code&gt;XDG_CURRENT_DESKTOP&lt;/code&gt; variable as well.
This change appears to be “backported” to Java 11 (but not Java 8).
So on Ubuntu 18.04, we have to unset both &lt;code&gt;GNOME_DESKTOP_SESSION_ID&lt;/code&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;code&gt;XDG_CURRENT_DESKTOP&lt;/code&gt; before starting &lt;code&gt;javaws&lt;/code&gt; with Java 11.
On ubuntu 20.04, only unsetting &lt;code&gt;XDG_CURRENT_DESKTOP&lt;/code&gt; is sufficient.&lt;/p&gt;
&lt;p&gt;So we can do, when we have &lt;code&gt;openjdk-11&lt;/code&gt; installed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gertjan:~$ unset -v GNOME_DESKTOP_SESSION_ID
gertjan:~$ unset -v XDG_CURRENT_DESKTOP
gertjan:~$ javaws ffblive.jnlp&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before finding this fix for Java 11, I went for a workaround instead: downgrading the JRE from version 11 to 8.
The rest of the blog post describes this journey.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fixing-the-problem&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Fixing the problem&lt;/h1&gt;
&lt;p&gt;So I decided to look into the matter, forensics style.&lt;/p&gt;
&lt;p&gt;From the &lt;code&gt;apt&lt;/code&gt; history (&lt;code&gt;/var/log/apt/history.1.gz&lt;/code&gt;), I found that on 19 december 2021, a new version of &lt;code&gt;openjdk-11&lt;/code&gt; was installed automatically:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Start-Date: 2021-12-19  09:31:26
Commandline: aptdaemon role=&amp;#39;role-commit-packages&amp;#39; sender=&amp;#39;:1.154&amp;#39;
Upgrade: openjdk-11-jre-headless:amd64 (11.0.11+9-0ubuntu2~18.04, 11.0.13+8-0ubuntu1~18.04), openjdk-11-jre:amd64 (11.0.11+9-0ubuntu2~18.04, 11.0.13+8-0ubuntu1~18.04)
End-Date: 2021-12-19  09:35:00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It seems that we went from &lt;code&gt;11.0.11+9-0ubuntu2~18.04&lt;/code&gt; to &lt;code&gt;11.0.13+8-0ubuntu1~18.04&lt;/code&gt;.
(Which is strange since there were a few releases in between as well according to the CHANGELOG)&lt;/p&gt;
&lt;p&gt;Trying to go back using &lt;code&gt;sudo apt-get install openjdk-11-jre-headless:amd64=11.0.11+9-0ubuntu2&lt;/code&gt; did not work.
From browsing &lt;a href=&#34;https://packages.ubuntu.com/&#34; class=&#34;uri&#34;&gt;https://packages.ubuntu.com/&lt;/a&gt; it seems that only the latest version of the &lt;code&gt;openjdk-11-jre&lt;/code&gt; package is available (18.04LTS, codename &lt;strong&gt;bionic&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;Remembering that the FUMBBL client always complains about “requesting JRE 1.6 and getting JRE 11.0” , I decided to try and downgrade openJDK: remove openJDK 11 and only install &lt;code&gt;openJDK-8&lt;/code&gt; to force &lt;code&gt;javaws&lt;/code&gt; to use JRE 1.8.&lt;/p&gt;
&lt;p&gt;To get a clean reproducible situation, I first removed all openJDK software from my system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt remove openjdk-11-jdk-headless
sudo apt remove jdk-11.0.9  #(installed this manually in a distant past apparently)
sudo apt remove openjdk-8-jre-headless&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This removes all openjdk packages, including &lt;code&gt;icedtea-netx&lt;/code&gt;, the package which contains the &lt;code&gt;javaws&lt;/code&gt; Java web start to start &lt;code&gt;*.jnlp&lt;/code&gt; files.
&lt;code&gt;/usr/lib/jvm&lt;/code&gt; is empty now on my system.&lt;/p&gt;
&lt;p&gt;I then installed the &lt;code&gt;openjdk-8-jre&lt;/code&gt; package (plus the &lt;code&gt;openjdk-8-jre-headless&lt;/code&gt; just to be safe):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install openjdk-8-jre
sudo apt install openjdk-8-jre-headless
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After this, I have indeed a working JRE 1.8 environment:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gertjan:~$ java -version
openjdk version &amp;quot;1.8.0_312&amp;quot;
OpenJDK Runtime Environment (build 1.8.0_312-8u312-b07-0ubuntu1~18.04-b07)
OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, no &lt;code&gt;javaws&lt;/code&gt; (Web start) is present. This is in a separate package called &lt;code&gt;icedtea&lt;/code&gt; (something to do with licensing or ?).&lt;/p&gt;
&lt;p&gt;So we do &lt;code&gt;sudo apt install icedtea-plugin&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The following NEW packages will be installed:
  default-jre default-jre-headless icedtea-8-plugin icedtea-netx
  icedtea-plugin openjdk-11-jre openjdk-11-jre-headless&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So if we want &lt;code&gt;icedtea&lt;/code&gt;, we also get &lt;code&gt;openjdk-11&lt;/code&gt; as a hard dependency.
Lets play along and install those packages.&lt;/p&gt;
&lt;p&gt;This brings &lt;code&gt;javaws&lt;/code&gt; to our system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javaws --version
selected jre: /usr/lib/jvm/default-java
WARNING: package javax.jnlp not in java.desktop
icedtea-web 1.8 (1.8)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It displays a text that gives us a hint how &lt;code&gt;javaws&lt;/code&gt; chooses its JRE: by looking at &lt;code&gt;/usr/lib/jvm/default-java&lt;/code&gt;.
This is at this point a symbolic link pointing at &lt;code&gt;openjdk-11&lt;/code&gt;.
Indeed, starting the FFB client with &lt;code&gt;javaws&lt;/code&gt; chooses openjdk 11 automatically.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gertjan:~$ javaws ffblive.jnlp

selected jre: /usr/lib/jvm/default-java
WARNING: package javax.jnlp not in java.desktop
Warning - your JRE - 11.0.13 - does not match requested JRE - 1.6
Warning - your JRE - 11.0.13 - does not match requested JRE - 1.6
Warning - your JRE - 11.0.13 - does not match requested JRE - 1.6
Warning - your JRE - 11.0.13 - does not match requested JRE - 1.6
Codebase matches codebase manifest attribute, and application is signed. Continuing. See: http://docs.oracle.com/javase/7/docs/technotes/guides/jweb/security/no_redeploy.html for details.
Starting application [com.fumbbl.ffb.client.FantasyFootballClient] ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This gives us the FFB client with the larger font and white bar covering the lower part of the screen.&lt;/p&gt;
&lt;p&gt;At first I tried setting the &lt;code&gt;JAVA_HOME&lt;/code&gt; variable, pointing it to &lt;code&gt;/usr/lib/jvm/java-8-openjdk-amd64&lt;/code&gt;. Previously, this did not work, but possible because I had only installed the &lt;code&gt;headless&lt;/code&gt; version of openjdk-8.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gertjan:~/Downloads$ export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
gertjan:~/Downloads$ unset -v GNOME_DESKTOP_SESSION_ID
gertjan:~/Downloads$ unset -v XDG_CURRENT_DESKTOP
gertjan:~/Downloads$ javaws ./ffblive.jnlp 
selected jre: /usr/lib/jvm/java-8-openjdk-amd64/jre/
Warning - your JRE - 1.8.0_312 - does not match requested JRE - 1.6
Warning - your JRE - 1.8.0_312 - does not match requested JRE - 1.6
Warning - your JRE - 1.8.0_312 - does not match requested JRE - 1.6
Warning - your JRE - 1.8.0_312 - does not match requested JRE - 1.6
Codebase matches codebase manifest attribute, and application is signed. Continuing. See: http://docs.oracle.com/javase/7/docs/technotes/guides/jweb/security/no_redeploy.html for details.
Starting application [com.fumbbl.ffb.client.FantasyFootballClient] ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This now works as well. If &lt;code&gt;JAVA_HOME&lt;/code&gt; is not set, &lt;code&gt;javaws&lt;/code&gt; looks at &lt;code&gt;/usr/lib/jvm/default-java&lt;/code&gt; to choose the JRE.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gertjan:~/Downloads$ unset JAVA_HOME
gertjan:~/Downloads$ javaws ./ffblive.jnlp 
selected jre: /usr/lib/jvm/default-java
WARNING: package javax.jnlp not in java.desktop
Warning - your JRE - 11.0.13 - does not match requested JRE - 1.6
Warning - your JRE - 11.0.13 - does not match requested JRE - 1.6
Warning - your JRE - 11.0.13 - does not match requested JRE - 1.6
Warning - your JRE - 11.0.13 - does not match requested JRE - 1.6
Codebase matches codebase manifest attribute, and application is signed. Continuing. See: http://docs.oracle.com/javase/7/docs/technotes/guides/jweb/security/no_redeploy.html for details.
Starting application [com.fumbbl.ffb.client.FantasyFootballClient] ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So instead of setting &lt;code&gt;JAVA_HOME&lt;/code&gt;, we can also change the symbolic link in &lt;code&gt;/usr/lib/jvm/default-java&lt;/code&gt; to point at &lt;code&gt;java-8-openjdk-amd64&lt;/code&gt; instead of pointing at &lt;code&gt;java-11-openjdk-amd64&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gertjan:~$ ls /usr/lib/jvm -lt
total 8
drwxr-xr-x 7 root root 4096 jan  4 19:46 java-11-openjdk-amd64
drwxr-xr-x 5 root root 4096 jan  4 19:43 java-8-openjdk-amd64
lrwxrwxrwx 1 root root   20 nov  3 14:54 java-1.8.0-openjdk-amd64 -&amp;gt; java-8-openjdk-amd64
lrwxrwxrwx 1 root root   21 okt 29 11:11 java-1.11.0-openjdk-amd64 -&amp;gt; java-11-openjdk-amd64
lrwxrwxrwx 1 root root   25 feb 20  2019 default-java -&amp;gt; java-1.11.0-openjdk-amd64

gertjan:~$ sudo rm /usr/lib/jvm/default-java

gertjan:~$ cd /usr/lib/jvm/

gertjan:/usr/lib/jvm$ sudo ln -ns java-1.8.0-openjdk-amd64 default-java&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we need fix the &lt;code&gt;java.security&lt;/code&gt; thingy by commenting out the following lines in &lt;code&gt;java.security&lt;/code&gt; (located somewhere in the &lt;code&gt;/usr/lib/jvm/java-8-openjdk-amd64&lt;/code&gt; file tree) with a text editor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo gedit /usr/lib/jvm/default-java/jre/lib/security/java.security &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These lines must be commented:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#jdk.jar.disabledAlgorithms=MD2, MD5, RSA keySize &amp;lt; 1024, \
#      DSA keySize &amp;lt; 1024, include jdk.disabled.namedCurves&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the hurting has not stopped yet on Ubuntu 18.04. &lt;code&gt;openjdk-8&lt;/code&gt; throws a new error, about “Assistive Technology” (not seen on Ubuntu 20.04LTS, where I first fixed these problems):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gertjan:~/Downloads$ javaws ffblive.jnlp

selected jre: /usr/lib/jvm/default-java
Exception in thread &amp;quot;main&amp;quot; java.awt.AWTError: Assistive Technology not found: org.GNOME.Accessibility.AtkWrapper
    at java.awt.Toolkit.loadAssistiveTechnologies(Toolkit.java:807)
    at java.awt.Toolkit.getDefaultToolkit(Toolkit.java:886)
    at javax.swing.UIManager.getSystemLookAndFeelClassName(UIManager.java:611)
    at net.sourceforge.jnlp.runtime.JNLPRuntime.initialize(JNLPRuntime.java:221)
    at net.sourceforge.jnlp.runtime.Boot.init(Boot.java:349)
    at net.sourceforge.jnlp.runtime.JnlpBoot.run(JnlpBoot.java:58)
    at net.sourceforge.jnlp.runtime.Boot.run(Boot.java:270)
    at net.sourceforge.jnlp.runtime.Boot.run(Boot.java:63)
    at java.security.AccessController.doPrivileged(Native Method)
    at net.sourceforge.jnlp.runtime.Boot.main(Boot.java:210)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fortunately, this is a well documented error with an easy solution.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://askubuntu.com/questions/695560/assistive-technology-not-found-awterror&#34; class=&#34;uri&#34;&gt;https://askubuntu.com/questions/695560/assistive-technology-not-found-awterror&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Provided in the form of this oneliner:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sed -i -e &amp;#39;/^assistive_technologies=/s/^/#/&amp;#39; /etc/java-*-openjdk/accessibility.properties`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally … we have a working FFB client again, without the white bar! Hurrah!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
